From d8cd584371a85f919fca009f43f4d5cbfb3d5bee Mon Sep 17 00:00:00 2001
From: jhenrique09 <jhsv09@gmail.com>
Date: Wed, 9 Feb 2022 22:16:43 -0300
Subject: [PATCH] Import of Face Unlock for T (1/2)

Squash of:
- Initial import of Face Unlock for S
- services: Merge T changes on our custom face unlock impl
- Add idle lockout message for FaceUnlock
- FaceService: Allow our face unlock to be used on third-party apps
- KeyguardBouncer: Don't delay showing if face auth running
- base: do not use new lockscreen layout for bypass
- [1/2] Allow changing face unlock method when locked
- Do not show camera indicator for Face Unlock service
- WalletActivity: Don't explicity request face auth
- Reset face auth on occluding app when authenticated
- SystemUI: Tell user when face unlock detection is running
- face: Pass requestId on our authentication client
- Hide face recognizing message on bouncer when authenticated

Change-Id: I0f8ab8ee816466e64f54dccd80de1a09e6c09d01
---
 core/java/android/provider/Settings.java      |   6 +
 core/res/res/values/config.xml                |   8 +
 core/res/res/values/strings.xml               |   6 +-
 core/res/res/values/symbols.xml               |   3 +
 .../validators/SecureSettingsValidators.java  |   1 +
 packages/SystemUI/Android.bp                  |   1 +
 packages/SystemUI/res/values/strings.xml      |   3 +
 .../keyguard/KeyguardUpdateMonitor.java       |  88 +-
 .../interactor/PrimaryBouncerInteractor.kt    |   8 +-
 .../privacy/AppOpsPrivacyItemMonitor.kt       |  10 +-
 .../KeyguardIndicationController.java         |  72 +-
 .../phone/BiometricUnlockController.java      |   2 +-
 .../phone/KeyguardBypassController.kt         |  47 +-
 .../phone/StatusBarKeyguardViewManager.java   |  56 +-
 .../systemui/wallet/ui/WalletActivity.java    |   4 +-
 services/core/Android.bp                      |   1 +
 .../server/biometrics/AuthSession.java        |   5 +
 .../server/biometrics/BiometricService.java   |  20 +-
 .../server/biometrics/PreAuthInfo.java        |   5 +
 .../biometrics/sensors/face/FaceService.java  |   9 +
 .../sensors/face/custom/ArrayUtils.java       |  65 ++
 .../face/custom/BiometricTestSessionImpl.java | 165 ++++
 .../face/custom/CustomFaceProvider.java       | 848 ++++++++++++++++++
 .../face/custom/FaceAuthenticationClient.java | 141 +++
 .../sensors/face/custom/FaceEnrollClient.java | 101 +++
 .../custom/FaceGenerateChallengeClient.java   |  94 ++
 .../face/custom/FaceGetFeatureClient.java     |  88 ++
 .../custom/FaceInternalCleanupClient.java     |  49 +
 .../custom/FaceInternalEnumerateClient.java   |  50 ++
 .../face/custom/FaceRemovalClient.java        |  53 ++
 .../face/custom/FaceResetLockoutClient.java   |  71 ++
 .../custom/FaceRevokeChallengeClient.java     |  48 +
 .../face/custom/FaceSetFeatureClient.java     |  80 ++
 .../custom/FaceUpdateActiveUserClient.java    |  76 ++
 .../sensors/face/custom/TestHal.java          | 128 +++
 .../policy/PermissionPolicyService.java       |   8 +
 36 files changed, 2370 insertions(+), 50 deletions(-)
 create mode 100644 services/core/java/com/android/server/biometrics/sensors/face/custom/ArrayUtils.java
 create mode 100644 services/core/java/com/android/server/biometrics/sensors/face/custom/BiometricTestSessionImpl.java
 create mode 100644 services/core/java/com/android/server/biometrics/sensors/face/custom/CustomFaceProvider.java
 create mode 100644 services/core/java/com/android/server/biometrics/sensors/face/custom/FaceAuthenticationClient.java
 create mode 100644 services/core/java/com/android/server/biometrics/sensors/face/custom/FaceEnrollClient.java
 create mode 100644 services/core/java/com/android/server/biometrics/sensors/face/custom/FaceGenerateChallengeClient.java
 create mode 100644 services/core/java/com/android/server/biometrics/sensors/face/custom/FaceGetFeatureClient.java
 create mode 100644 services/core/java/com/android/server/biometrics/sensors/face/custom/FaceInternalCleanupClient.java
 create mode 100644 services/core/java/com/android/server/biometrics/sensors/face/custom/FaceInternalEnumerateClient.java
 create mode 100644 services/core/java/com/android/server/biometrics/sensors/face/custom/FaceRemovalClient.java
 create mode 100644 services/core/java/com/android/server/biometrics/sensors/face/custom/FaceResetLockoutClient.java
 create mode 100644 services/core/java/com/android/server/biometrics/sensors/face/custom/FaceRevokeChallengeClient.java
 create mode 100644 services/core/java/com/android/server/biometrics/sensors/face/custom/FaceSetFeatureClient.java
 create mode 100644 services/core/java/com/android/server/biometrics/sensors/face/custom/FaceUpdateActiveUserClient.java
 create mode 100644 services/core/java/com/android/server/biometrics/sensors/face/custom/TestHal.java

diff --git a/core/java/android/provider/Settings.java b/core/java/android/provider/Settings.java
index 8d8379831e87..1ed7b5412eef 100644
--- a/core/java/android/provider/Settings.java
+++ b/core/java/android/provider/Settings.java
@@ -11106,6 +11106,12 @@ public final class Settings {
          */
         public static final String LOCK_SCREEN_WEATHER_ENABLED = "lockscreen_weather_enabled";
 
+        /**
+         * Face Unlock Method
+         * @hide
+         */
+        public static final String FACE_UNLOCK_METHOD = "face_unlock_method";
+
         /**
          * These entries are considered common between the personal and the managed profile,
          * since the managed profile doesn't get to change them.
diff --git a/core/res/res/values/config.xml b/core/res/res/values/config.xml
index 72176d4dbf6a..7273e2ddcc5c 100644
--- a/core/res/res/values/config.xml
+++ b/core/res/res/values/config.xml
@@ -6139,4 +6139,12 @@
     <!-- Whether we should persist the brightness value in nits for the default display even if
          the underlying display device changes. -->
     <bool name="config_persistBrightnessNitsForDefaultDisplay">false</bool>
+
+    <!-- Array containing custom error messages from vendor. -->
+    <string-array name="face_error_vendor" translatable="false">
+        <item>@string/face_unlock_disabled_idle</item>
+    </string-array>
+
+    <!-- Enable face auth only when swiping security view -->
+    <bool name="config_faceAuthOnlyOnSecurityView">false</bool>
 </resources>
diff --git a/core/res/res/values/strings.xml b/core/res/res/values/strings.xml
index 6888edcf7d3c..bbcbdaabe054 100644
--- a/core/res/res/values/strings.xml
+++ b/core/res/res/values/strings.xml
@@ -1914,9 +1914,6 @@
     <!-- Subtitle shown on the system-provided biometric dialog, asking the user to authenticate with their face or screen lock credential (i.e. PIN, pattern, or password). [CHAR LIMIT=90] -->
     <string name="face_or_screen_lock_dialog_default_subtitle">Use your face or screen lock to continue</string>
 
-    <!-- Array containing custom error messages from vendor.  Vendor is expected to add and translate these strings -->
-    <string-array name="face_error_vendor">
-    </string-array>
     <!-- Default error message to use when face_error_vendor does not contain a message. [CHAR LIMIT=NONE] -->
     <string name="face_error_vendor_unknown">Something went wrong. Try again.</string>
 
@@ -6371,4 +6368,7 @@ ul.</string>
 
     <!-- Title for preference of the system default locale. [CHAR LIMIT=50]-->
     <string name="system_locale_title">System default</string>
+
+    <!-- Face unlock -->
+    <string name="face_unlock_disabled_idle">Face unlock disabled due to inactivity</string>
 </resources>
diff --git a/core/res/res/values/symbols.xml b/core/res/res/values/symbols.xml
index 01c6b5509cb7..df03c76b8657 100644
--- a/core/res/res/values/symbols.xml
+++ b/core/res/res/values/symbols.xml
@@ -4915,4 +4915,7 @@
 
   <!-- Whether to show weather on the lockscreen by default. -->
   <java-symbol type="bool" name="config_lockscreenWeatherEnabledByDefault" />
+
+  <!-- Enable face auth only when swiping security view -->
+  <java-symbol type="bool" name="config_faceAuthOnlyOnSecurityView" />
 </resources>
diff --git a/packages/SettingsProvider/src/android/provider/settings/validators/SecureSettingsValidators.java b/packages/SettingsProvider/src/android/provider/settings/validators/SecureSettingsValidators.java
index 44992f259d1c..6a79d18ef82e 100644
--- a/packages/SettingsProvider/src/android/provider/settings/validators/SecureSettingsValidators.java
+++ b/packages/SettingsProvider/src/android/provider/settings/validators/SecureSettingsValidators.java
@@ -357,5 +357,6 @@ public class SecureSettingsValidators {
         VALIDATORS.put(Secure.BLUETOOTH_LE_BROADCAST_APP_SOURCE_NAME, ANY_STRING_VALIDATOR);
         VALIDATORS.put(Secure.LOCK_SCREEN_WEATHER_ENABLED, BOOLEAN_VALIDATOR);
         VALIDATORS.put(Secure.ACCESSIBILITY_FONT_SCALING_HAS_BEEN_CHANGED, BOOLEAN_VALIDATOR);
+        VALIDATORS.put(Secure.FACE_UNLOCK_METHOD, BOOLEAN_VALIDATOR);
     }
 }
diff --git a/packages/SystemUI/Android.bp b/packages/SystemUI/Android.bp
index dc2244c94080..71f2f3b204f5 100644
--- a/packages/SystemUI/Android.bp
+++ b/packages/SystemUI/Android.bp
@@ -178,6 +178,7 @@ android_library {
         "LowLightDreamLib",
         "motion_tool_lib",
         "vendor.goodix.hardware.biometrics.fingerprint-V2.1-java",
+        "faceunlock_framework",
     ],
     manifest: "AndroidManifest.xml",
 
diff --git a/packages/SystemUI/res/values/strings.xml b/packages/SystemUI/res/values/strings.xml
index 81241c91d1c6..2384dac6a7a6 100644
--- a/packages/SystemUI/res/values/strings.xml
+++ b/packages/SystemUI/res/values/strings.xml
@@ -2865,4 +2865,7 @@
 
     <!-- Content description for priority mode icon on dream [CHAR LIMIT=NONE] -->
     <string name="priority_mode_dream_overlay_content_description">Priority mode on</string>
+
+    <!-- Face Unlock -->
+    <string name="face_unlock_recognizing">Recognizing face...</string>
 </resources>
diff --git a/packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java b/packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java
index e154695e56e3..0c5b97e59a94 100644
--- a/packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java
+++ b/packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java
@@ -82,6 +82,7 @@ import android.app.trust.TrustManager;
 import android.content.BroadcastReceiver;
 import android.content.ComponentName;
 import android.content.Context;
+import android.content.ContentResolver;
 import android.content.Intent;
 import android.content.IntentFilter;
 import android.content.pm.PackageManager;
@@ -467,6 +468,13 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener, Dumpab
 
     private static int sCurrentUser;
 
+    SettingsObserver mSettingsObserver;
+
+    private final boolean mFaceAuthOnlyOnSecurityView;
+    public static final int FACE_UNLOCK_BEHAVIOR_DEFAULT = 0;
+    public static final int FACE_UNLOCK_BEHAVIOR_SWIPE = 1;
+    private int mFaceUnlockBehavior = FACE_UNLOCK_BEHAVIOR_DEFAULT;
+
     public synchronized static void setCurrentUser(int currentUser) {
         sCurrentUser = currentUser;
     }
@@ -740,6 +748,7 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener, Dumpab
         final boolean wasKeyguardVisible = isKeyguardVisible();
         mKeyguardShowing = showing;
         mKeyguardOccluded = occluded;
+        mPrimaryBouncerFullyShown = false;
         final boolean isKeyguardVisible = isKeyguardVisible();
         mLogger.logKeyguardShowingChanged(showing, occluded, isKeyguardVisible);
 
@@ -933,6 +942,9 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener, Dumpab
 
     private void handleFingerprintAuthenticated(int authUserId, boolean isStrongBiometric) {
         Trace.beginSection("KeyGuardUpdateMonitor#handlerFingerPrintAuthenticated");
+        if (mOccludingAppRequestingFace){
+            requestFaceAuthOnOccludingApp(false);
+        }
         if (mHandler.hasCallbacks(mFpCancelNotReceived)) {
             mLogger.d("handleFingerprintAuthenticated()"
                     + " triggered while waiting for cancellation, removing watchdog");
@@ -1175,6 +1187,9 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener, Dumpab
 
     private void handleFaceAuthenticated(int authUserId, boolean isStrongBiometric) {
         Trace.beginSection("KeyGuardUpdateMonitor#handlerFaceAuthenticated");
+        if (mOccludingAppRequestingFace){
+            requestFaceAuthOnOccludingApp(false);
+        }
         try {
             if (mGoingToSleep) {
                 mLogger.d("Aborted successful auth because device is going to sleep.");
@@ -2148,6 +2163,8 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener, Dumpab
         mTelephonyListenerManager = telephonyListenerManager;
         mDeviceProvisioned = isDeviceProvisionedInSettingsDb();
         mStrongAuthTracker = new StrongAuthTracker(context);
+        mFaceAuthOnlyOnSecurityView = mContext.getResources().getBoolean(
+                com.android.internal.R.bool.config_faceAuthOnlyOnSecurityView);
         mBackgroundExecutor = backgroundExecutor;
         mBroadcastDispatcher = broadcastDispatcher;
         mInteractionJankMonitor = interactionJankMonitor;
@@ -2408,6 +2425,9 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener, Dumpab
                 false, mTimeFormatChangeObserver, UserHandle.USER_ALL);
 
         mFingerprintInteractiveToAuthProvider = interactiveToAuthProvider.orElse(null);
+
+        mSettingsObserver = new SettingsObserver(mHandler);
+        mSettingsObserver.observe();
     }
 
     private void initializeSimState() {
@@ -2919,7 +2939,7 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener, Dumpab
         final boolean isPostureAllowedForFaceAuth = doesPostureAllowFaceAuth(mPostureState);
         // Only listen if this KeyguardUpdateMonitor belongs to the primary user. There is an
         // instance of KeyguardUpdateMonitor for each user but KeyguardUpdateMonitor is user-aware.
-        final boolean shouldListen =
+        boolean shouldListen =
                 (mPrimaryBouncerFullyShown
                         || mAuthInterruptActive
                         || mOccludingAppRequestingFace
@@ -2935,6 +2955,10 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener, Dumpab
                 && !mGoingToSleep
                 && isPostureAllowedForFaceAuth;
 
+        if (shouldListen && mFaceUnlockBehavior == FACE_UNLOCK_BEHAVIOR_SWIPE && !mPrimaryBouncerFullyShown){
+            shouldListen = false;
+        }
+
         // Aggregate relevant fields for debug logging.
         logListenerModelData(
                 new KeyguardFaceListenModel(
@@ -2970,6 +2994,10 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener, Dumpab
                 || (posture == mConfigFaceAuthSupportedPosture);
     }
 
+    public int getFaceUnlockBehavior() {
+        return mFaceUnlockBehavior;
+    }
+
     private void logListenerModelData(@NonNull KeyguardListenModel model) {
         mLogger.logKeyguardListenerModel(model);
         if (model instanceof KeyguardFingerprintListenModel) {
@@ -3136,7 +3164,7 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener, Dumpab
         return mIsUnlockWithFingerprintPossible.getOrDefault(userId, false);
     }
 
-    private boolean isUnlockWithFacePossible(int userId) {
+    public boolean isUnlockWithFacePossible(int userId) {
         return isFaceAuthEnabledForUser(userId) && !isFaceDisabled(userId);
     }
 
@@ -3510,6 +3538,7 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener, Dumpab
         mLogger.d("handleKeyguardReset");
         updateBiometricListeningState(BIOMETRIC_ACTION_UPDATE,
                 FACE_AUTH_UPDATED_KEYGUARD_RESET);
+        mPrimaryBouncerFullyShown = false;
         mNeedsSlowUnlockTransition = resolveNeedsSlowUnlockTransition();
     }
 
@@ -3582,6 +3611,15 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener, Dumpab
         }
     }
 
+    public void updateFaceListeningStateForBehavior(boolean fullyShow) {
+        if (mPrimaryBouncerFullyShown != fullyShow){
+            mPrimaryBouncerFullyShown = fullyShow;
+            if (mFaceUnlockBehavior == FACE_UNLOCK_BEHAVIOR_SWIPE){
+                updateFaceListeningState(BIOMETRIC_ACTION_UPDATE, FACE_AUTH_UPDATED_ON_FACE_AUTHENTICATED);
+            }
+        }
+    }
+
     /**
      * Handle {@link #MSG_REQUIRE_NFC_UNLOCK}
      */
@@ -3612,6 +3650,7 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener, Dumpab
      * Handle {@link #MSG_REPORT_EMERGENCY_CALL_ACTION}
      */
     private void handleReportEmergencyCallAction() {
+        mPrimaryBouncerFullyShown = false;
         Assert.isMainThread();
         for (int i = 0; i < mCallbacks.size(); i++) {
             KeyguardUpdateMonitorCallback cb = mCallbacks.get(i).get();
@@ -4006,10 +4045,55 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener, Dumpab
         return BIOMETRIC_LOCKOUT_RESET_DELAY_MS;
     }
 
+    private void updateSettings() {
+        updateFaceUnlockBehavior();
+    }
+
+    private void updateFaceUnlockBehavior() {
+        ContentResolver resolver = mContext.getContentResolver();
+        if (mFaceAuthOnlyOnSecurityView){
+            mFaceUnlockBehavior = FACE_UNLOCK_BEHAVIOR_SWIPE;
+        }else{
+            mFaceUnlockBehavior = Settings.Secure.getIntForUser(resolver,
+                Settings.Secure.FACE_UNLOCK_METHOD, FACE_UNLOCK_BEHAVIOR_DEFAULT,
+                UserHandle.USER_CURRENT);
+        }
+    }
+
+    class SettingsObserver extends ContentObserver {
+        private ContentResolver mContentResolver;
+        SettingsObserver(Handler handler) {
+            super(handler);
+        }
+
+        void observe() {
+            mContentResolver = mContext.getContentResolver();
+            mContentResolver.registerContentObserver(Settings.Secure.getUriFor(
+                    Settings.Secure.FACE_UNLOCK_METHOD), false, this,
+                    UserHandle.USER_ALL);
+            updateSettings();
+        }
+
+        void unobserve(){
+            if (mContentResolver != null){
+                mContentResolver.unregisterContentObserver(this);
+            }
+        }
+
+        @Override
+        public void onChange(boolean selfChange) {
+            updateSettings();
+        }
+    }
+
     /**
      * Unregister all listeners.
      */
     public void destroy() {
+        if (mSettingsObserver != null) {
+            mSettingsObserver.unobserve();
+        }
+
         mStatusBarStateController.removeCallback(mStatusBarStateControllerListener);
         mTelephonyListenerManager.removeActiveDataSubscriptionIdListener(mPhoneStateListener);
         mSubscriptionManager.removeOnSubscriptionsChangedListener(mSubscriptionListener);
diff --git a/packages/SystemUI/src/com/android/systemui/keyguard/domain/interactor/PrimaryBouncerInteractor.kt b/packages/SystemUI/src/com/android/systemui/keyguard/domain/interactor/PrimaryBouncerInteractor.kt
index 59bcfe09df5d..cc0a35eb5ea3 100644
--- a/packages/SystemUI/src/com/android/systemui/keyguard/domain/interactor/PrimaryBouncerInteractor.kt
+++ b/packages/SystemUI/src/com/android/systemui/keyguard/domain/interactor/PrimaryBouncerInteractor.kt
@@ -179,11 +179,11 @@ constructor(
         }
 
         repository.setPrimaryShowingSoon(true)
-        if (primaryBouncerFaceDelay) {
+        /*if (primaryBouncerFaceDelay) {
             mainHandler.postDelayed(showRunnable, 1200L)
-        } else {
-            DejankUtils.postAfterTraversal(showRunnable)
-        }
+        } else {*/
+        DejankUtils.postAfterTraversal(showRunnable)
+        //}
         keyguardStateController.notifyPrimaryBouncerShowing(true)
         primaryBouncerCallbackInteractor.dispatchStartingToShow()
         Trace.endSection()
diff --git a/packages/SystemUI/src/com/android/systemui/privacy/AppOpsPrivacyItemMonitor.kt b/packages/SystemUI/src/com/android/systemui/privacy/AppOpsPrivacyItemMonitor.kt
index de34cd6b23ca..5b7f832afbaa 100644
--- a/packages/SystemUI/src/com/android/systemui/privacy/AppOpsPrivacyItemMonitor.kt
+++ b/packages/SystemUI/src/com/android/systemui/privacy/AppOpsPrivacyItemMonitor.kt
@@ -53,6 +53,9 @@ class AppOpsPrivacyItemMonitor @Inject constructor(
 
     @VisibleForTesting
     companion object {
+        val CAMERA_WHITELIST_PKG = arrayOf(
+            "org.pixelexperience.faceunlock",
+        )
         val OPS_MIC_CAMERA = intArrayOf(AppOpsManager.OP_CAMERA,
                 AppOpsManager.OP_PHONE_CALL_CAMERA, AppOpsManager.OP_RECORD_AUDIO,
                 AppOpsManager.OP_PHONE_CALL_MICROPHONE,
@@ -85,7 +88,8 @@ class AppOpsPrivacyItemMonitor @Inject constructor(
         ) {
             synchronized(lock) {
                 // Check if we care about this code right now
-                if (code in OPS_MIC_CAMERA && !micCameraAvailable) {
+                if (code in OPS_MIC_CAMERA && !micCameraAvailable
+                        || packageName in CAMERA_WHITELIST_PKG) {
                     return
                 }
                 if (code in OPS_LOCATION && !locationAvailable) {
@@ -213,6 +217,10 @@ class AppOpsPrivacyItemMonitor @Inject constructor(
             AppOpsManager.OP_RECORD_AUDIO -> PrivacyType.TYPE_MICROPHONE
             else -> return null
         }
+        if (type == PrivacyType.TYPE_CAMERA && !micCameraAvailable
+                || appOpItem.packageName in CAMERA_WHITELIST_PKG) {
+            return null
+        }
         val app = PrivacyApplication(appOpItem.packageName, appOpItem.uid)
         return PrivacyItem(type, app, appOpItem.timeStartedElapsed, appOpItem.isDisabled)
     }
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/KeyguardIndicationController.java b/packages/SystemUI/src/com/android/systemui/statusbar/KeyguardIndicationController.java
index d5751f4a349f..dd4473dda840 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/KeyguardIndicationController.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/KeyguardIndicationController.java
@@ -44,6 +44,7 @@ import static com.android.systemui.keyguard.KeyguardIndicationRotateTextViewCont
 import static com.android.systemui.keyguard.ScreenLifecycle.SCREEN_ON;
 import static com.android.systemui.plugins.FalsingManager.LOW_PENALTY;
 import static com.android.systemui.plugins.log.LogLevel.ERROR;
+import static com.android.keyguard.KeyguardUpdateMonitor.FACE_UNLOCK_BEHAVIOR_SWIPE;
 
 import android.app.AlarmManager;
 import android.app.admin.DevicePolicyManager;
@@ -134,6 +135,8 @@ public class KeyguardIndicationController {
 
     private static final int MSG_SHOW_ACTION_TO_UNLOCK = 1;
     private static final int MSG_RESET_ERROR_MESSAGE_ON_SCREEN_ON = 2;
+    private static final int MSG_SHOW_RECOGNIZING_FACE = 100;
+    private static final int MSG_HIDE_RECOGNIZING_FACE = 101;
     private static final long TRANSIENT_BIOMETRIC_ERROR_TIMEOUT = 1300;
     public static final long DEFAULT_HIDE_DELAY_MS =
             3500 + KeyguardIndicationTextView.Y_IN_DURATION;
@@ -195,6 +198,7 @@ public class KeyguardIndicationController {
     private final Set<Integer> mCoExFaceAcquisitionMsgIdsToShow;
     private final FaceHelpMessageDeferral mFaceAcquiredMessageDeferral;
     private boolean mInited;
+    private boolean mFaceDetectionRunning;
 
     private KeyguardUpdateMonitorCallback mUpdateMonitorCallback;
 
@@ -214,6 +218,15 @@ public class KeyguardIndicationController {
                 mBiometricErrorMessageToShowOnScreenOn = null;
             }
         }
+
+        @Override
+        public void onScreenTurnedOff() {
+            if (mFaceDetectionRunning) {
+                mFaceDetectionRunning = false;
+                mBiometricErrorMessageToShowOnScreenOn = null;
+                hideFaceUnlockRecognizingMessage();
+            }
+        }
     };
     private boolean mFaceLockedOutThisAuthSession;
 
@@ -289,6 +302,11 @@ public class KeyguardIndicationController {
                     showActionToUnlock();
                 } else if (msg.what == MSG_RESET_ERROR_MESSAGE_ON_SCREEN_ON) {
                     mBiometricErrorMessageToShowOnScreenOn = null;
+                } else if (msg.what == MSG_SHOW_RECOGNIZING_FACE){
+                    mBiometricErrorMessageToShowOnScreenOn = null;
+                    showFaceUnlockRecognizingMessage();
+                } else if (msg.what == MSG_HIDE_RECOGNIZING_FACE){
+                    hideFaceUnlockRecognizingMessage();
                 }
             }
         };
@@ -821,6 +839,44 @@ public class KeyguardIndicationController {
         }
     }
 
+    private void showFaceUnlockRecognizingMessage() {
+        if (mKeyguardUpdateMonitor.getFaceUnlockBehavior() == FACE_UNLOCK_BEHAVIOR_SWIPE){
+            return;
+        }
+
+        mHandler.removeMessages(MSG_SHOW_ACTION_TO_UNLOCK);
+        hideBiometricMessage();
+
+        mBiometricMessage = mContext.getResources().getString(
+                                    R.string.face_unlock_recognizing);
+
+        mRotateTextViewController.updateIndication(
+                INDICATION_TYPE_BIOMETRIC_MESSAGE,
+                new KeyguardIndication.Builder()
+                        .setMessage(mBiometricMessage)
+                        .setMinVisibilityMillis(6000L) // 6 seconds
+                        .setTextColor(mInitialTextColorState)
+                        .build(),
+                true
+        );
+
+        if (mDozing) {
+            updateDeviceEntryIndication(false);
+        }
+    }
+
+    private void hideFaceUnlockRecognizingMessage() {
+        if (mKeyguardUpdateMonitor.getFaceUnlockBehavior() == FACE_UNLOCK_BEHAVIOR_SWIPE){
+            return;
+        }
+
+        String faceUnlockMessage = mContext.getResources().getString(
+            R.string.face_unlock_recognizing);
+        if (mBiometricMessage != null && mBiometricMessage == faceUnlockMessage) {
+            hideBiometricMessage();
+        }
+    }
+
     /**
      * Hides transient indication.
      */
@@ -1279,11 +1335,17 @@ public class KeyguardIndicationController {
         @Override
         public void onBiometricRunningStateChanged(boolean running,
                 BiometricSourceType biometricSourceType) {
-            if (running && biometricSourceType == FACE) {
-                // Let's hide any previous messages when authentication starts, otherwise
-                // multiple auth attempts would overlap.
-                hideBiometricMessage();
-                mBiometricErrorMessageToShowOnScreenOn = null;
+            if (biometricSourceType == BiometricSourceType.FACE) {
+                mFaceDetectionRunning = running;
+                if (running) {
+                    mHandler.removeMessages(MSG_HIDE_RECOGNIZING_FACE);
+                    mHandler.removeMessages(MSG_SHOW_RECOGNIZING_FACE);
+                    mHandler.sendEmptyMessageDelayed(MSG_SHOW_RECOGNIZING_FACE, 100);
+                }else{
+                    mHandler.removeMessages(MSG_SHOW_RECOGNIZING_FACE);
+                    mHandler.removeMessages(MSG_HIDE_RECOGNIZING_FACE);
+                    mHandler.sendEmptyMessageDelayed(MSG_HIDE_RECOGNIZING_FACE, 100);
+                }
             }
         }
 
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/phone/BiometricUnlockController.java b/packages/SystemUI/src/com/android/systemui/statusbar/phone/BiometricUnlockController.java
index 573347cb1aff..528c7ce899ef 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/phone/BiometricUnlockController.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/phone/BiometricUnlockController.java
@@ -610,7 +610,7 @@ public class BiometricUnlockController extends KeyguardUpdateMonitorCallback imp
         final boolean unlockingAllowed =
                 mUpdateMonitor.isUnlockingWithBiometricAllowed(isStrongBiometric);
         final boolean deviceDreaming = mUpdateMonitor.isDreaming();
-        final boolean bypass = mKeyguardBypassController.getBypassEnabled()
+        final boolean bypass = mKeyguardBypassController.getBypassEnabledBiometric()
                 || mAuthController.isUdfpsFingerDown();
 
         logCalculateModeForPassiveAuth(unlockingAllowed, deviceInteractive, isKeyguardShowing,
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/phone/KeyguardBypassController.kt b/packages/SystemUI/src/com/android/systemui/statusbar/phone/KeyguardBypassController.kt
index ff1b31d8848f..3124068c2cd3 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/phone/KeyguardBypassController.kt
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/phone/KeyguardBypassController.kt
@@ -105,6 +105,10 @@ open class KeyguardBypassController : Dumpable, StackScrollAlgorithm.BypassContr
             notifyListeners()
         }
 
+    var bypassEnabledBiometric: Boolean = false
+
+    var faceUnlockMethod: Int = 0
+
     var bouncerShowing: Boolean = false
     var altBouncerShowing: Boolean = false
     var launchingAffordance: Boolean = false
@@ -160,19 +164,29 @@ open class KeyguardBypassController : Dumpable, StackScrollAlgorithm.BypassContr
             }
         }
 
-        val dismissByDefault = if (context.resources.getBoolean(
-                        com.android.internal.R.bool.config_faceAuthDismissesKeyguard)) 1 else 0
-        tunerService.addTunable(object : TunerService.Tunable {
-            override fun onTuningChanged(key: String?, newValue: String?) {
-                bypassEnabled = tunerService.getValue(key, dismissByDefault) != 0
-            }
-        }, Settings.Secure.FACE_UNLOCK_DISMISSES_KEYGUARD)
-        lockscreenUserManager.addUserChangedListener(
-                object : NotificationLockscreenUserManager.UserChangedListener {
-                    override fun onUserChanged(userId: Int) {
-                        pendingUnlock = null
-                    }
-                })
+        if (context.resources.getBoolean(
+                com.android.internal.R.bool.config_faceAuthOnlyOnSecurityView)){
+            bypassEnabledBiometric = false
+        }else{
+            tunerService.addTunable(object : TunerService.Tunable {
+                override fun onTuningChanged(key: String?, newValue: String?) {
+                    faceUnlockMethod = tunerService.getValue(key, 0)
+                }
+            }, Settings.Secure.FACE_UNLOCK_METHOD)
+            val dismissByDefault = if (context.resources.getBoolean(
+                            com.android.internal.R.bool.config_faceAuthDismissesKeyguard)) 1 else 0
+            tunerService.addTunable(object : TunerService.Tunable {
+                override fun onTuningChanged(key: String?, newValue: String?) {
+                    bypassEnabledBiometric = tunerService.getValue(key, dismissByDefault) != 0
+                }
+            }, Settings.Secure.FACE_UNLOCK_DISMISSES_KEYGUARD)
+            lockscreenUserManager.addUserChangedListener(
+                    object : NotificationLockscreenUserManager.UserChangedListener {
+                        override fun onUserChanged(userId: Int) {
+                            pendingUnlock = null
+                        }
+                    })
+        }
     }
 
     private fun notifyListeners() = listeners.forEach { it.onBypassStateChanged(bypassEnabled) }
@@ -186,8 +200,8 @@ open class KeyguardBypassController : Dumpable, StackScrollAlgorithm.BypassContr
         biometricSourceType: BiometricSourceType,
         isStrongBiometric: Boolean
     ): Boolean {
-        if (biometricSourceType == BiometricSourceType.FACE && bypassEnabled) {
-            val can = canBypass()
+        if (bypassEnabledBiometric) {
+            val can = biometricSourceType != BiometricSourceType.FACE || canBypass()
             if (!can && (isPulseExpanding || qsExpanded)) {
                 pendingUnlock = PendingUnlock(biometricSourceType, isStrongBiometric)
             }
@@ -211,7 +225,7 @@ open class KeyguardBypassController : Dumpable, StackScrollAlgorithm.BypassContr
      * If keyguard can be dismissed because of bypass.
      */
     fun canBypass(): Boolean {
-        if (bypassEnabled) {
+        if (bypassEnabledBiometric) {
             return when {
                 bouncerShowing -> true
                 altBouncerShowing -> true
@@ -244,6 +258,7 @@ open class KeyguardBypassController : Dumpable, StackScrollAlgorithm.BypassContr
             pw.println("  mPendingUnlock: $pendingUnlock")
         }
         pw.println("  bypassEnabled: $bypassEnabled")
+        pw.println("  bypassEnabledBiometric: $bypassEnabledBiometric")
         pw.println("  canBypass: ${canBypass()}")
         pw.println("  bouncerShowing: $bouncerShowing")
         pw.println("  altBouncerShowing: $altBouncerShowing")
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java b/packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java
index 71e2e405d071..8305a39d9a89 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java
@@ -28,6 +28,7 @@ import android.content.Context;
 import android.content.res.ColorStateList;
 import android.hardware.biometrics.BiometricSourceType;
 import android.os.Bundle;
+import android.os.Handler;
 import android.os.SystemClock;
 import android.os.Trace;
 import android.util.Log;
@@ -55,6 +56,7 @@ import com.android.keyguard.KeyguardUpdateMonitorCallback;
 import com.android.keyguard.KeyguardViewController;
 import com.android.keyguard.ViewMediatorCallback;
 import com.android.systemui.dagger.SysUISingleton;
+import com.android.systemui.dagger.qualifiers.Main;
 import com.android.systemui.dock.DockManager;
 import com.android.systemui.dreams.DreamOverlayStateController;
 import com.android.systemui.flags.FeatureFlags;
@@ -84,6 +86,7 @@ import com.android.systemui.statusbar.policy.ConfigurationController;
 import com.android.systemui.statusbar.policy.KeyguardStateController;
 import com.android.systemui.unfold.FoldAodAnimationController;
 import com.android.systemui.unfold.SysUIUnfoldComponent;
+import com.android.systemui.R;
 
 import java.io.PrintWriter;
 import java.util.ArrayList;
@@ -145,6 +148,8 @@ public class StatusBarKeyguardViewManager implements RemoteInputController.Callb
     private float mFraction = -1f;
     private boolean mTracking = false;
 
+    private boolean mBouncerVisible = false;
+
     private final PrimaryBouncerExpansionCallback mExpansionCallback =
             new PrimaryBouncerExpansionCallback() {
             private boolean mPrimaryBouncerAnimating;
@@ -153,6 +158,7 @@ public class StatusBarKeyguardViewManager implements RemoteInputController.Callb
             public void onFullyShown() {
                 mPrimaryBouncerAnimating = false;
                 updateStates();
+                showFaceRecognizingMessage();
             }
 
             @Override
@@ -185,6 +191,7 @@ public class StatusBarKeyguardViewManager implements RemoteInputController.Callb
                 mCentralSurfaces.setBouncerShowingOverDream(
                         isVisible && mDreamOverlayStateController.isOverlayActive());
 
+                mBouncerVisible = isVisible;
                 if (!isVisible) {
                     mCentralSurfaces.setPrimaryBouncerHiddenFraction(EXPANSION_HIDDEN);
                 }
@@ -302,6 +309,11 @@ public class StatusBarKeyguardViewManager implements RemoteInputController.Callb
     @Nullable private OccludingAppBiometricUI mOccludingAppBiometricUI;
 
     @Nullable private TaskbarDelegate mTaskbarDelegate;
+
+    private Handler mHandler;
+    private Handler mFaceRecognizingHandler;
+    private boolean mFaceRecognitionRunning = false;
+
     private final KeyguardUpdateMonitorCallback mUpdateMonitorCallback =
             new KeyguardUpdateMonitorCallback() {
         @Override
@@ -312,6 +324,28 @@ public class StatusBarKeyguardViewManager implements RemoteInputController.Callb
                 reset(true /* hideBouncerWhenShowing */);
             }
         }
+
+        @Override
+        public void onBiometricRunningStateChanged(boolean running,
+                BiometricSourceType biometricSourceType) {
+            if (biometricSourceType == BiometricSourceType.FACE &&
+                    mKeyguardUpdateManager.isUnlockWithFacePossible(mKeyguardUpdateManager.getCurrentUser())){
+                mFaceRecognitionRunning = running;
+                if (!mFaceRecognitionRunning){
+                    mFaceRecognizingHandler.removeCallbacksAndMessages(null);
+                }else{
+                    mFaceRecognizingHandler.postDelayed(() -> showFaceRecognizingMessage(), 100);
+                }
+            }
+        }
+
+        @Override
+        public void onBiometricAuthenticated(int userId, BiometricSourceType biometricSourceType,
+                boolean isStrongBiometric) {
+            if (biometricSourceType == BiometricSourceType.FACE) {
+                hideFaceRecognizingMessage();
+            }
+        }
     };
 
     @Inject
@@ -337,7 +371,9 @@ public class StatusBarKeyguardViewManager implements RemoteInputController.Callb
             PrimaryBouncerCallbackInteractor primaryBouncerCallbackInteractor,
             PrimaryBouncerInteractor primaryBouncerInteractor,
             BouncerView primaryBouncerView,
-            AlternateBouncerInteractor alternateBouncerInteractor) {
+            AlternateBouncerInteractor alternateBouncerInteractor,
+            @Main Handler handler,
+            @Main Handler faceRecognizingHandler) {
         mContext = context;
         mViewMediatorCallback = callback;
         mLockPatternUtils = lockPatternUtils;
@@ -363,6 +399,8 @@ public class StatusBarKeyguardViewManager implements RemoteInputController.Callb
         mAlternateBouncerInteractor = alternateBouncerInteractor;
         mIsBackAnimationEnabled =
                 featureFlags.isEnabled(Flags.WM_ENABLE_PREDICTIVE_BACK_BOUNCER_ANIM);
+        mHandler = handler;
+        mFaceRecognizingHandler = faceRecognizingHandler;
     }
 
     @Override
@@ -704,6 +742,11 @@ public class StatusBarKeyguardViewManager implements RemoteInputController.Callb
             }
         }
         updateStates();
+        mHandler.postDelayed(() -> {
+            if (mBouncerVisible) {
+                mKeyguardUpdateManager.updateFaceListeningStateForBehavior(mBouncerVisible);
+            }
+        }, 100);
     }
 
     private boolean isWakeAndUnlocking() {
@@ -1314,6 +1357,17 @@ public class StatusBarKeyguardViewManager implements RemoteInputController.Callb
         }
     }
 
+    private void showFaceRecognizingMessage(){
+        if (mFaceRecognitionRunning &&
+                mKeyguardUpdateManager.isUnlockWithFacePossible(mKeyguardUpdateManager.getCurrentUser())) {
+            setKeyguardMessage(mContext.getString(R.string.face_unlock_recognizing), null);
+        }
+    }
+
+    private void hideFaceRecognizingMessage(){
+        setKeyguardMessage("", null);
+    }
+
     /** Display security message to relevant KeyguardMessageArea. */
     public void setKeyguardMessage(String message, ColorStateList colorState) {
         if (mAlternateBouncerInteractor.isVisibleState()) {
diff --git a/packages/SystemUI/src/com/android/systemui/wallet/ui/WalletActivity.java b/packages/SystemUI/src/com/android/systemui/wallet/ui/WalletActivity.java
index d03148cee335..83def7645c13 100644
--- a/packages/SystemUI/src/com/android/systemui/wallet/ui/WalletActivity.java
+++ b/packages/SystemUI/src/com/android/systemui/wallet/ui/WalletActivity.java
@@ -209,14 +209,14 @@ public class WalletActivity extends ComponentActivity implements
                 true,
                 Utils.getColorAttrDefaultColor(
                         this, com.android.internal.R.attr.colorAccentPrimary));
-        mKeyguardViewManager.requestFace(true);
+        //mKeyguardViewManager.requestFace(true);
     }
 
     @Override
     protected void onPause() {
         super.onPause();
         mKeyguardViewManager.requestFp(false, -1);
-        mKeyguardViewManager.requestFace(false);
+        //mKeyguardViewManager.requestFace(false);
     }
 
     @Override
diff --git a/services/core/Android.bp b/services/core/Android.bp
index 145a74a43464..0893f111421c 100644
--- a/services/core/Android.bp
+++ b/services/core/Android.bp
@@ -180,6 +180,7 @@ java_library_static {
         "vendor.samsung.hardware.biometrics.fingerprint-V3.0-java",
         "vendor.oplus.hardware.biometrics.fingerprint-V2.1-java",
         "vendor.oppo.hardware.biometrics.fingerprint-V2.1-java",
+        "faceunlock_framework",
     ],
     javac_shard_size: 50,
 }
diff --git a/services/core/java/com/android/server/biometrics/AuthSession.java b/services/core/java/com/android/server/biometrics/AuthSession.java
index 41ca13f5d5f5..2af0af945d3c 100644
--- a/services/core/java/com/android/server/biometrics/AuthSession.java
+++ b/services/core/java/com/android/server/biometrics/AuthSession.java
@@ -70,6 +70,8 @@ import java.util.List;
 import java.util.Random;
 import java.util.function.Function;
 
+import com.android.internal.util.custom.faceunlock.FaceUnlockUtils;
+
 /**
  * Class that defines the states of an authentication session invoked via
  * {@link android.hardware.biometrics.BiometricPrompt}, as well as all of the necessary
@@ -331,6 +333,9 @@ public final class AuthSession implements IBinder.DeathRecipient {
     }
 
     private boolean isConfirmationRequired(BiometricSensor sensor) {
+        if (sensor.modality == TYPE_FACE && FaceUnlockUtils.isFaceUnlockSupported()) {
+            return true;
+        }
         return sensor.confirmationSupported()
                 && (sensor.confirmationAlwaysRequired(mUserId)
                 || mPreAuthInfo.confirmationRequested);
diff --git a/services/core/java/com/android/server/biometrics/BiometricService.java b/services/core/java/com/android/server/biometrics/BiometricService.java
index 4767969bd3ed..4805d97c34cd 100644
--- a/services/core/java/com/android/server/biometrics/BiometricService.java
+++ b/services/core/java/com/android/server/biometrics/BiometricService.java
@@ -85,6 +85,8 @@ import java.util.Set;
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.function.Supplier;
 
+import com.android.internal.util.custom.faceunlock.FaceUnlockUtils;
+
 /**
  * System service that arbitrates the modality for BiometricPrompt to use.
  */
@@ -214,10 +216,6 @@ public class BiometricService extends SystemService {
         private static final boolean DEFAULT_APP_ENABLED = true;
         private static final boolean DEFAULT_ALWAYS_REQUIRE_CONFIRMATION = false;
 
-        // Some devices that shipped before S already have face-specific settings. Instead of
-        // migrating, which is complicated, let's just keep using the existing settings.
-        private final boolean mUseLegacyFaceOnlySettings;
-
         // Only used for legacy face-only devices
         private final Uri FACE_UNLOCK_KEYGUARD_ENABLED =
                 Settings.Secure.getUriFor(Settings.Secure.FACE_UNLOCK_KEYGUARD_ENABLED);
@@ -257,18 +255,13 @@ public class BiometricService extends SystemService {
             final boolean hasFace = context.getPackageManager()
                     .hasSystemFeature(PackageManager.FEATURE_FACE);
 
-            // Use the legacy setting on face-only devices that shipped on or before Q
-            mUseLegacyFaceOnlySettings =
-                    Build.VERSION.DEVICE_INITIAL_SDK_INT <= Build.VERSION_CODES.Q
-                    && hasFace && !hasFingerprint;
-
             updateContentObserver();
         }
 
         public void updateContentObserver() {
             mContentResolver.unregisterContentObserver(this);
 
-            if (mUseLegacyFaceOnlySettings) {
+            if (FaceUnlockUtils.isFaceUnlockSupported()) {
                 mContentResolver.registerContentObserver(FACE_UNLOCK_KEYGUARD_ENABLED,
                         false /* notifyForDescendants */,
                         this /* observer */,
@@ -338,7 +331,7 @@ public class BiometricService extends SystemService {
 
         public boolean getEnabledOnKeyguard(int userId) {
             if (!mBiometricEnabledOnKeyguard.containsKey(userId)) {
-                if (mUseLegacyFaceOnlySettings) {
+                if (FaceUnlockUtils.isFaceUnlockSupported()) {
                     onChange(true /* selfChange */, FACE_UNLOCK_KEYGUARD_ENABLED, userId);
                 } else {
                     onChange(true /* selfChange */, BIOMETRIC_KEYGUARD_ENABLED, userId);
@@ -349,7 +342,7 @@ public class BiometricService extends SystemService {
 
         public boolean getEnabledForApps(int userId) {
             if (!mBiometricEnabledForApps.containsKey(userId)) {
-                if (mUseLegacyFaceOnlySettings) {
+                if (FaceUnlockUtils.isFaceUnlockSupported()) {
                     onChange(true /* selfChange */, FACE_UNLOCK_APP_ENABLED, userId);
                 } else {
                     onChange(true /* selfChange */, BIOMETRIC_APP_ENABLED, userId);
@@ -1323,9 +1316,6 @@ public class BiometricService extends SystemService {
     }
 
     private void dumpInternal(PrintWriter pw) {
-        pw.println("Legacy Settings: " + mSettingObserver.mUseLegacyFaceOnlySettings);
-        pw.println();
-
         pw.println("Sensors:");
         for (BiometricSensor sensor : mSensors) {
             pw.println(" " + sensor);
diff --git a/services/core/java/com/android/server/biometrics/PreAuthInfo.java b/services/core/java/com/android/server/biometrics/PreAuthInfo.java
index aec98f0ea426..b694746b69b7 100644
--- a/services/core/java/com/android/server/biometrics/PreAuthInfo.java
+++ b/services/core/java/com/android/server/biometrics/PreAuthInfo.java
@@ -42,6 +42,8 @@ import java.lang.annotation.RetentionPolicy;
 import java.util.ArrayList;
 import java.util.List;
 
+import com.android.internal.util.custom.faceunlock.FaceUnlockUtils;
+
 /**
  * Class representing the calling client's request. Additionally, derives/calculates
  * preliminary info that would be useful in helping serve this request. Note that generating
@@ -227,6 +229,9 @@ class PreAuthInfo {
 
     private static boolean isEnabledForApp(BiometricService.SettingObserver settingObserver,
             @BiometricAuthenticator.Modality int modality, int userId) {
+        if (modality == TYPE_FINGERPRINT && FaceUnlockUtils.isFaceUnlockSupported()){
+            return true;
+        }
         return settingObserver.getEnabledForApps(userId);
     }
 
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/FaceService.java b/services/core/java/com/android/server/biometrics/sensors/face/FaceService.java
index 5491379b39ac..804daf1abc70 100644
--- a/services/core/java/com/android/server/biometrics/sensors/face/FaceService.java
+++ b/services/core/java/com/android/server/biometrics/sensors/face/FaceService.java
@@ -25,6 +25,7 @@ import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.content.Context;
 import android.hardware.biometrics.BiometricManager;
+import android.hardware.biometrics.SensorProperties;
 import android.hardware.biometrics.BiometricsProtoEnums;
 import android.hardware.biometrics.IBiometricSensorReceiver;
 import android.hardware.biometrics.IBiometricService;
@@ -62,6 +63,7 @@ import com.android.server.biometrics.sensors.ClientMonitorCallbackConverter;
 import com.android.server.biometrics.sensors.LockoutResetDispatcher;
 import com.android.server.biometrics.sensors.LockoutTracker;
 import com.android.server.biometrics.sensors.face.aidl.FaceProvider;
+import com.android.server.biometrics.sensors.face.custom.CustomFaceProvider;
 import com.android.server.biometrics.sensors.face.hidl.Face10;
 
 import java.io.FileDescriptor;
@@ -647,6 +649,12 @@ public class FaceService extends SystemService {
             }
         }
 
+        private void addCustomProviders() {
+            if (CustomFaceProvider.useCustomFaceUnlockService()) {
+                mServiceProviders.add(new CustomFaceProvider(getContext(), new FaceSensorPropertiesInternal(CustomFaceProvider.DEVICE_ID, SensorProperties.STRENGTH_WEAK, 1, new ArrayList(), 1, false, false, false), mLockoutResetDispatcher));
+            }
+        }
+
         @Override // Binder call
         public void registerAuthenticators(
                 @NonNull List<FaceSensorPropertiesInternal> hidlSensors) {
@@ -664,6 +672,7 @@ public class FaceService extends SystemService {
             handler.post(() -> {
                 addHidlProviders(hidlSensors);
                 addAidlProviders();
+                addCustomProviders();
 
                 final IBiometricService biometricService = IBiometricService.Stub.asInterface(
                         ServiceManager.getService(Context.BIOMETRIC_SERVICE));
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/custom/ArrayUtils.java b/services/core/java/com/android/server/biometrics/sensors/face/custom/ArrayUtils.java
new file mode 100644
index 000000000000..617781c0a08f
--- /dev/null
+++ b/services/core/java/com/android/server/biometrics/sensors/face/custom/ArrayUtils.java
@@ -0,0 +1,65 @@
+/*
+* Copyright (C) 2022 The Pixel Experience Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package com.android.server.biometrics.sensors.face.custom;
+
+import java.util.ArrayList;
+
+public class ArrayUtils {
+    public static ArrayList<Byte> toByteArrayList(byte[] in) {
+        if (in == null) {
+            return null;
+        }
+        ArrayList<Byte> out = new ArrayList<>(in.length);
+        for (byte c : in) {
+            out.add(c);
+        }
+        return out;
+    }
+
+    public static ArrayList<Integer> toIntArrayList(int[] in) {
+        if (in == null) {
+            return null;
+        }
+        ArrayList<Integer> out = new ArrayList<>(in.length);
+        for (int c : in) {
+            out.add(c);
+        }
+        return out;
+    }
+
+    public static int[] toIntArray(ArrayList<Integer> in) {
+        if (in == null) {
+            return null;
+        }
+        int[] out = new int[in.size()];
+        for (int i = 0; i < in.size(); i++) {
+            out[i] = in.get(i);
+        }
+        return out;
+    }
+
+    public static byte[] toByteArray(ArrayList<Byte> in) {
+        if (in == null) {
+            return null;
+        }
+        byte[] out = new byte[in.size()];
+        for (int i = 0; i < in.size(); i++) {
+            out[i] = in.get(i);
+        }
+        return out;
+    }
+}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/custom/BiometricTestSessionImpl.java b/services/core/java/com/android/server/biometrics/sensors/face/custom/BiometricTestSessionImpl.java
new file mode 100644
index 000000000000..83e772b0e20b
--- /dev/null
+++ b/services/core/java/com/android/server/biometrics/sensors/face/custom/BiometricTestSessionImpl.java
@@ -0,0 +1,165 @@
+/*
+* Copyright (C) 2022 The Pixel Experience Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package com.android.server.biometrics.sensors.face.custom;
+
+import android.content.Context;
+import android.hardware.biometrics.ITestSession;
+import android.hardware.biometrics.ITestSessionCallback;
+import android.hardware.face.Face;
+import android.hardware.face.FaceAuthenticationFrame;
+import android.hardware.face.FaceEnrollFrame;
+import android.hardware.face.IFaceServiceReceiver;
+import android.os.Binder;
+import android.os.RemoteException;
+import android.util.Slog;
+
+import com.android.server.biometrics.Utils;
+import com.android.server.biometrics.sensors.BaseClientMonitor;
+import com.android.server.biometrics.sensors.ClientMonitorCallback;
+import com.android.server.biometrics.sensors.face.FaceUtils;
+
+import java.util.List;
+import java.util.Random;
+
+public class BiometricTestSessionImpl extends ITestSession.Stub {
+    private static final String TAG = "BiometricTestSessionImpl";
+    private final ITestSessionCallback mCallback;
+    private final Context mContext;
+    private final CustomFaceProvider.HalResultController mHalResultController;
+    private final CustomFaceProvider mCustomFaceProvider;
+    private final int mSensorId;
+    private final IFaceServiceReceiver mReceiver = new IFaceServiceReceiver.Stub() {
+        @Override
+        public void onEnrollResult(Face face, int remaining) {
+        }
+
+        @Override
+        public void onAcquired(int acquiredInfo, int vendorCode) {
+        }
+
+        @Override
+        public void onAuthenticationSucceeded(Face face, int userId, boolean isStrongBiometric) {
+        }
+
+        @Override
+        public void onFaceDetected(int sensorId, int userId, boolean isStrongBiometric) {
+        }
+
+        @Override
+        public void onAuthenticationFailed() {
+        }
+
+        @Override
+        public void onError(int error, int vendorCode) {
+        }
+
+        @Override
+        public void onRemoved(Face face, int remaining) {
+        }
+
+        @Override
+        public void onFeatureSet(boolean success, int feature) {
+        }
+
+        @Override
+        public void onFeatureGet(boolean success, int[] features, boolean[] featureState) {
+        }
+
+        public void onChallengeGenerated(int sensorId, int userId, long challenge) {
+        }
+
+        @Override
+        public void onAuthenticationFrame(FaceAuthenticationFrame frame) {
+        }
+
+        @Override
+        public void onEnrollmentFrame(FaceEnrollFrame frame) {
+        }
+    };
+    private final Random mRandom = new Random();
+
+    public BiometricTestSessionImpl(Context context, int sensorId, ITestSessionCallback callback, CustomFaceProvider customFaceProvider, CustomFaceProvider.HalResultController halResultController) {
+        mContext = context;
+        mSensorId = sensorId;
+        mCallback = callback;
+        mCustomFaceProvider = customFaceProvider;
+        mHalResultController = halResultController;
+    }
+
+    public void setTestHalEnabled(boolean enabled) {
+        Utils.checkPermission(mContext, "android.permission.TEST_BIOMETRIC");
+        mCustomFaceProvider.setTestHalEnabled(enabled);
+    }
+
+    public void startEnroll(int userId) {
+        Utils.checkPermission(mContext, "android.permission.TEST_BIOMETRIC");
+        mCustomFaceProvider.scheduleEnroll(mSensorId, new Binder(), new byte[69], userId, mReceiver, mContext.getOpPackageName(), new int[0], null, false);
+    }
+
+    public void finishEnroll(int userId) {
+        Utils.checkPermission(mContext, "android.permission.TEST_BIOMETRIC");
+        mHalResultController.onEnrollResult(1, userId, 0);
+    }
+
+    public void acceptAuthentication(int userId) {
+        Utils.checkPermission(mContext, "android.permission.TEST_BIOMETRIC");
+        List<Face> faces = FaceUtils.getLegacyInstance(mSensorId).getBiometricsForUser(mContext, userId);
+        if (faces.isEmpty()) {
+            Slog.w(TAG, "No faces, returning");
+        } else {
+            mHalResultController.onAuthenticated(faces.get(0).getBiometricId(), userId, new byte[]{0});
+        }
+    }
+
+    public void rejectAuthentication(int userId) {
+        Utils.checkPermission(mContext, "android.permission.TEST_BIOMETRIC");
+        mHalResultController.onAuthenticated(0, userId, null);
+    }
+
+    public void notifyAcquired(int userId, int acquireInfo) {
+        Utils.checkPermission(mContext, "android.permission.TEST_BIOMETRIC");
+        mHalResultController.onAcquired(userId, acquireInfo, 0);
+    }
+
+    public void notifyError(int userId, int errorCode) {
+        Utils.checkPermission(mContext, "android.permission.TEST_BIOMETRIC");
+        mHalResultController.onError(errorCode, 0);
+    }
+
+    public void cleanupInternalState(int userId) {
+        Utils.checkPermission(mContext, "android.permission.TEST_BIOMETRIC");
+        mCustomFaceProvider.scheduleInternalCleanup(mSensorId, userId, new ClientMonitorCallback() {
+            @Override
+            public void onClientStarted(BaseClientMonitor clientMonitor) {
+                try {
+                    mCallback.onCleanupStarted(clientMonitor.getTargetUserId());
+                } catch (RemoteException e) {
+                    Slog.e(BiometricTestSessionImpl.TAG, "Remote exception", e);
+                }
+            }
+
+            @Override
+            public void onClientFinished(BaseClientMonitor clientMonitor, boolean success) {
+                try {
+                    mCallback.onCleanupFinished(clientMonitor.getTargetUserId());
+                } catch (RemoteException e) {
+                    Slog.e(BiometricTestSessionImpl.TAG, "Remote exception", e);
+                }
+            }
+        });
+    }
+}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/custom/CustomFaceProvider.java b/services/core/java/com/android/server/biometrics/sensors/face/custom/CustomFaceProvider.java
new file mode 100644
index 000000000000..b362cf4ad707
--- /dev/null
+++ b/services/core/java/com/android/server/biometrics/sensors/face/custom/CustomFaceProvider.java
@@ -0,0 +1,848 @@
+/*
+* Copyright (C) 2022 The Pixel Experience Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package com.android.server.biometrics.sensors.face.custom;
+
+import android.app.ActivityManager;
+import android.app.SynchronousUserSwitchObserver;
+import android.content.BroadcastReceiver;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.ServiceConnection;
+import android.content.pm.PackageManager;
+import android.content.pm.ResolveInfo;
+import android.content.pm.UserInfo;
+import android.hardware.biometrics.BiometricsProtoEnums;
+import android.hardware.biometrics.IInvalidationCallback;
+import android.hardware.biometrics.ITestSession;
+import android.hardware.biometrics.ITestSessionCallback;
+import android.hardware.face.Face;
+import android.hardware.face.FaceSensorPropertiesInternal;
+import android.hardware.face.IFaceServiceReceiver;
+import android.os.Binder;
+import android.os.Handler;
+import android.os.IBinder;
+import android.os.Looper;
+import android.os.RemoteException;
+import android.os.UserHandle;
+import android.os.UserManager;
+import android.provider.Settings;
+import android.util.Slog;
+import android.util.SparseArray;
+import android.util.proto.ProtoOutputStream;
+import android.view.Surface;
+
+import android.annotation.NonNull;
+
+import com.android.internal.util.custom.faceunlock.FaceUnlockUtils;
+import com.android.internal.util.custom.faceunlock.IFaceService;
+import com.android.server.biometrics.SensorServiceStateProto;
+import com.android.server.biometrics.SensorStateProto;
+import com.android.server.biometrics.UserStateProto;
+import com.android.server.biometrics.Utils;
+import com.android.server.biometrics.log.BiometricContext;
+import com.android.server.biometrics.log.BiometricLogger;
+import com.android.server.biometrics.sensors.AcquisitionClient;
+import com.android.server.biometrics.sensors.AuthenticationConsumer;
+import com.android.server.biometrics.sensors.BaseClientMonitor;
+import com.android.server.biometrics.sensors.ClientMonitorCallback;
+import com.android.server.biometrics.sensors.BiometricNotificationUtils;
+import com.android.server.biometrics.sensors.BiometricScheduler;
+import com.android.server.biometrics.sensors.ClientMonitorCallbackConverter;
+import com.android.server.biometrics.sensors.EnumerateConsumer;
+import com.android.server.biometrics.sensors.ErrorConsumer;
+import com.android.server.biometrics.sensors.LockoutResetDispatcher;
+import com.android.server.biometrics.sensors.PerformanceTracker;
+import com.android.server.biometrics.sensors.RemovalConsumer;
+import com.android.server.biometrics.sensors.face.FaceUtils;
+import com.android.server.biometrics.sensors.face.LockoutHalImpl;
+import com.android.server.biometrics.sensors.face.ServiceProvider;
+import com.android.server.biometrics.sensors.face.UsageStats;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.FileDescriptor;
+import java.io.PrintWriter;
+import java.time.Clock;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.function.Supplier;
+
+public class CustomFaceProvider implements ServiceProvider {
+    public static final int DEVICE_ID = 1008;
+    private static final int ENROLL_TIMEOUT_SEC = 75;
+    private static final int GENERATE_CHALLENGE_COUNTER_TTL_MILLIS = 600000;
+    private static final int GENERATE_CHALLENGE_REUSE_INTERVAL_MILLIS = 60000;
+    private static final String TAG = CustomFaceProvider.class.getSimpleName();
+    public static Clock sSystemClock = Clock.systemUTC();
+    final SparseArray<IFaceService> mFaceServices;
+    private final Map<Integer, Long> mAuthenticatorIds;
+    private final Context mContext;
+    private final List<Long> mGeneratedChallengeCount;
+    private final HalResultController mHalResultController;
+    private final Handler mHandler;
+    private final Supplier<IFaceService> mLazyDaemon;
+    private final LockoutHalImpl mLockoutTracker;
+    private final BiometricScheduler mScheduler;
+    private final int mSensorId;
+    private final FaceSensorPropertiesInternal mSensorProperties;
+    private final UsageStats mUsageStats;
+    @NonNull
+    private final AtomicLong mRequestCounter = new AtomicLong(0);
+    private int mCurrentUserId;
+    private FaceGenerateChallengeClient mGeneratedChallengeCache;
+    private boolean mIsServiceBinding;
+    private TestHal mTestHal;
+    private boolean mTestHalEnabled;
+
+    private BiometricContext mBiometricContext;
+
+    CustomFaceProvider(Context context, FaceSensorPropertiesInternal sensorProps, LockoutResetDispatcher lockoutResetDispatcher, BiometricScheduler scheduler) {
+        mBiometricContext = BiometricContext.getInstance(context);
+        mTestHalEnabled = false;
+        mCurrentUserId = -10000;
+        mGeneratedChallengeCount = new ArrayList<>();
+        mGeneratedChallengeCache = null;
+        mFaceServices = new SparseArray<>();
+        mIsServiceBinding = false;
+        mSensorProperties = sensorProps;
+        mContext = context;
+        mSensorId = sensorProps.sensorId;
+        mScheduler = scheduler;
+        Handler handler = new Handler(Looper.getMainLooper());
+        mHandler = handler;
+        mUsageStats = new UsageStats(context);
+        mAuthenticatorIds = new HashMap<>();
+        mLazyDaemon = CustomFaceProvider.this::getDaemon;
+        LockoutHalImpl lockoutHalImpl = new LockoutHalImpl();
+        mLockoutTracker = lockoutHalImpl;
+        HalResultController halResultController = new HalResultController(sensorProps.sensorId, context, handler, scheduler, lockoutHalImpl, lockoutResetDispatcher);
+        mHalResultController = halResultController;
+        halResultController.setCallback(() -> {
+            mCurrentUserId = -10000;
+        });
+        mCurrentUserId = ActivityManager.getCurrentUser();
+        try {
+            ActivityManager.getService().registerUserSwitchObserver(new SynchronousUserSwitchObserver() {
+                public void onUserSwitching(int newUserId) {
+                    Slog.d(TAG, "user switch : newUserId = " + newUserId);
+                    mCurrentUserId = newUserId;
+                    if (getDaemon() == null) {
+                        bindFaceAuthService(mCurrentUserId);
+                    }
+                }
+            }, TAG);
+        } catch (RemoteException e) {
+            Slog.e(TAG, "Unable to register user switch observer");
+        }
+        context.registerReceiver(new BroadcastReceiver() {
+            @Override
+            public void onReceive(Context context2, Intent intent) {
+                if (getDaemon() == null) {
+                    bindFaceAuthService(mCurrentUserId);
+                }
+            }
+        }, new IntentFilter("android.intent.action.USER_UNLOCKED"));
+    }
+
+    public CustomFaceProvider(Context context, FaceSensorPropertiesInternal sensorProps, LockoutResetDispatcher lockoutResetDispatcher) {
+        this(context, sensorProps, lockoutResetDispatcher, new BiometricScheduler(TAG, 0, null));
+    }
+
+    synchronized IFaceService getDaemon() {
+        if (mTestHalEnabled) {
+            if (mTestHal == null) {
+                mTestHal = new TestHal(mCurrentUserId, mContext, mSensorId);
+            }
+            try {
+                mTestHal.setCallback(mHalResultController);
+            } catch (RemoteException e) {
+                e.printStackTrace();
+            }
+            return mTestHal;
+        }
+        IFaceService service = getFaceService(mCurrentUserId);
+        if (service == null) {
+            bindFaceAuthService(mCurrentUserId);
+        }
+        return service;
+    }
+
+    @Override
+    public boolean containsSensor(int sensorId) {
+        return mSensorId == sensorId;
+    }
+
+    @Override
+    public List<FaceSensorPropertiesInternal> getSensorProperties() {
+        List<FaceSensorPropertiesInternal> properties = new ArrayList<>();
+        properties.add(mSensorProperties);
+        return properties;
+    }
+
+    @Override
+    public FaceSensorPropertiesInternal getSensorProperties(int sensorId) {
+        return mSensorProperties;
+    }
+
+    @Override
+    public List<Face> getEnrolledFaces(int sensorId, int userId) {
+        return FaceUtils.getLegacyInstance(mSensorId).getBiometricsForUser(mContext, userId);
+    }
+
+    @Override
+    public int getLockoutModeForUser(int sensorId, int userId) {
+        return mLockoutTracker.getLockoutModeForUser(userId);
+    }
+
+    @Override
+    public long getAuthenticatorId(int sensorId, int userId) {
+        return mAuthenticatorIds.getOrDefault(Integer.valueOf(userId), 0L).longValue();
+    }
+
+    @Override
+    public boolean isHardwareDetected(int sensorId) {
+        return getDaemon() != null;
+    }
+
+    private boolean isGeneratedChallengeCacheValid() {
+        return mGeneratedChallengeCache != null && sSystemClock.millis() - mGeneratedChallengeCache.getCreatedAt() < GENERATE_CHALLENGE_REUSE_INTERVAL_MILLIS;
+    }
+
+    private void incrementChallengeCount() {
+        mGeneratedChallengeCount.add(0, sSystemClock.millis());
+    }
+
+    private int decrementChallengeCount() {
+        mGeneratedChallengeCount.removeIf(aLong -> sSystemClock.millis() - aLong > GENERATE_CHALLENGE_COUNTER_TTL_MILLIS);
+        if (!mGeneratedChallengeCount.isEmpty()) {
+            mGeneratedChallengeCount.remove(0);
+        }
+        return mGeneratedChallengeCount.size();
+    }
+
+    @Override
+    public void scheduleGenerateChallenge(int sensorId, int userId, IBinder token, IFaceServiceReceiver receiver, String opPackageName) {
+        mHandler.post(() -> {
+            if (getDaemon() == null) {
+                bindFaceAuthService(mCurrentUserId);
+                try {
+                    receiver.onChallengeGenerated(sensorId, userId, 0);
+                } catch (RemoteException e) {
+                    e.printStackTrace();
+                }
+            } else {
+                incrementChallengeCount();
+                if (isGeneratedChallengeCacheValid()) {
+                    Slog.d(TAG, "Current challenge is cached and will be reused");
+                    mGeneratedChallengeCache.reuseResult(receiver);
+                    return;
+                }
+                scheduleUpdateActiveUserWithoutHandler(userId);
+                final FaceGenerateChallengeClient client = new FaceGenerateChallengeClient(mContext, mLazyDaemon, token, new ClientMonitorCallbackConverter(receiver), userId, opPackageName, mSensorId, createLogger(BiometricsProtoEnums.ACTION_UNKNOWN, BiometricsProtoEnums.CLIENT_UNKNOWN), mBiometricContext, sSystemClock.millis());
+                mGeneratedChallengeCache = client;
+                mScheduler.scheduleClientMonitor(client, new ClientMonitorCallback() {
+                    @Override
+                    public void onClientStarted(BaseClientMonitor clientMonitor) {
+                        if (client != clientMonitor) {
+                            Slog.e(TAG, "scheduleGenerateChallenge onClientStarted, mismatched client. Expecting: " + client + ", received: " + clientMonitor);
+                        }
+                    }
+                });
+            }
+        });
+    }
+
+    @Override
+    public void scheduleRevokeChallenge(int sensorId, int userId, IBinder token, String opPackageName, long challenge) {
+        mHandler.post(() -> {
+            if (getDaemon() == null) {
+                bindFaceAuthService(mCurrentUserId);
+                return;
+            }
+            if (!(decrementChallengeCount() == 0)) {
+                Slog.w(TAG, "scheduleRevokeChallenge skipped - challenge still in use: " + mGeneratedChallengeCount);
+                return;
+            }
+            Slog.d(TAG, "scheduleRevokeChallenge executing - no active clients");
+            mGeneratedChallengeCache = null;
+            final FaceRevokeChallengeClient client = new FaceRevokeChallengeClient(mContext, mLazyDaemon, token, userId, opPackageName, mSensorId, createLogger(BiometricsProtoEnums.ACTION_UNKNOWN, BiometricsProtoEnums.CLIENT_UNKNOWN), mBiometricContext);
+            mScheduler.scheduleClientMonitor(client, new ClientMonitorCallback() {
+                @Override
+                public void onClientFinished(BaseClientMonitor clientMonitor, boolean success) {
+                    if (client != clientMonitor) {
+                        Slog.e(TAG, "scheduleRevokeChallenge, mismatched client.Expecting: " + client + ", received: " + clientMonitor);
+                    }
+                }
+            });
+        });
+    }
+
+    @Override
+    public long scheduleEnroll(int sensorId, IBinder token, byte[] hardwareAuthToken, int userId, IFaceServiceReceiver receiver, String opPackageName, int[] disabledFeatures, Surface previewSurface, boolean debugConsent) {
+        final long id = mRequestCounter.incrementAndGet();
+        mHandler.post(() -> {
+            if (getDaemon() == null) {
+                bindFaceAuthService(mCurrentUserId);
+                try {
+                    receiver.onError(2, 0);
+                } catch (RemoteException e) {
+                    e.printStackTrace();
+                }
+            } else {
+                scheduleUpdateActiveUserWithoutHandler(userId);
+                BiometricNotificationUtils.cancelReEnrollNotification(mContext);
+                final FaceEnrollClient client = new FaceEnrollClient(mContext, mLazyDaemon, token, new ClientMonitorCallbackConverter(receiver), userId, hardwareAuthToken, opPackageName, FaceUtils.getLegacyInstance(mSensorId), disabledFeatures, ENROLL_TIMEOUT_SEC, previewSurface, mSensorId, createLogger(BiometricsProtoEnums.ACTION_ENROLL, BiometricsProtoEnums.CLIENT_UNKNOWN), mBiometricContext);
+                mScheduler.scheduleClientMonitor(client, new ClientMonitorCallback() {
+                    @Override
+                    public void onClientFinished(BaseClientMonitor clientMonitor, boolean success) {
+                        if (success) {
+                            scheduleUpdateActiveUserWithoutHandler(client.getTargetUserId());
+                        }
+                    }
+                });
+            }
+        });
+        return id;
+    }
+
+    @Override
+    public void cancelEnrollment(int sensorId, IBinder token, long requestId) {
+        mHandler.post(() -> mScheduler.cancelEnrollment(token, requestId));
+    }
+
+    @Override
+    public long scheduleFaceDetect(int sensorId, IBinder token, int userId, ClientMonitorCallbackConverter callback, String opPackageName, int statsClient) {
+        throw new IllegalStateException("Face detect not supported by IBiometricsFace@1.0. Did youforget to check the supportsFaceDetection flag?");
+    }
+
+    @Override
+    public void cancelFaceDetect(int sensorId, IBinder token, long requestId) {
+        throw new IllegalStateException("Face detect not supported by IBiometricsFace@1.0. Did youforget to check the supportsFaceDetection flag?");
+    }
+
+    @Override
+    public long scheduleAuthenticate(int sensorId, IBinder token, long operationId,
+                                     int userId, int cookie, ClientMonitorCallbackConverter receiver,
+                                     String opPackageName, boolean restricted, int statsClient,
+                                     boolean allowBackgroundAuthentication, boolean isKeyguardBypassEnabled) {
+        final long id = mRequestCounter.incrementAndGet();
+        scheduleAuthenticate(sensorId, token, operationId, userId, cookie, receiver,
+                opPackageName, id, restricted, statsClient,
+                allowBackgroundAuthentication, isKeyguardBypassEnabled);
+        return id;
+    }
+
+    @Override
+    public void scheduleAuthenticate(int sensorId, IBinder token, long operationId, int userId, int cookie, ClientMonitorCallbackConverter receiver, String opPackageName, long requestId, boolean restricted, int statsClient, boolean allowBackgroundAuthentication, boolean isKeyguardBypassEnabled) {
+        mHandler.post(() -> {
+            if (getDaemon() == null) {
+                bindFaceAuthService(mCurrentUserId);
+                try {
+                    receiver.onError(DEVICE_ID, 0, 1, 0);
+                } catch (RemoteException e) {
+                    e.printStackTrace();
+                }
+            } else {
+                scheduleUpdateActiveUserWithoutHandler(userId);
+                mScheduler.scheduleClientMonitor(new FaceAuthenticationClient(mContext, mLazyDaemon, token, requestId, receiver, userId, operationId, restricted, opPackageName, cookie, false, mSensorId, createLogger(BiometricsProtoEnums.ACTION_AUTHENTICATE, statsClient), mBiometricContext, Utils.isStrongBiometric(mSensorId), mLockoutTracker, mUsageStats, allowBackgroundAuthentication));
+            }
+        });
+    }
+
+    @Override
+    public void cancelAuthentication(int sensorId, IBinder token, long requestId) {
+        mHandler.post(() -> mScheduler.cancelAuthenticationOrDetection(token, requestId));
+    }
+
+    @Override
+    public void scheduleRemove(int sensorId, IBinder token, int faceId, int userId, IFaceServiceReceiver receiver, String opPackageName) {
+        mHandler.post(() -> {
+            if (getDaemon() == null) {
+                bindFaceAuthService(mCurrentUserId);
+                try {
+                    receiver.onError(1, 0);
+                } catch (RemoteException e) {
+                    e.printStackTrace();
+                }
+            } else {
+                scheduleUpdateActiveUserWithoutHandler(userId);
+                mScheduler.scheduleClientMonitor(new FaceRemovalClient(mContext, mLazyDaemon, token, new ClientMonitorCallbackConverter(receiver), faceId, userId, opPackageName, FaceUtils.getLegacyInstance(mSensorId), mSensorId, createLogger(BiometricsProtoEnums.ACTION_REMOVE, BiometricsProtoEnums.CLIENT_UNKNOWN), mBiometricContext, mAuthenticatorIds));
+            }
+        });
+    }
+
+    @Override
+    public void scheduleRemoveAll(int sensorId, IBinder token, int userId, IFaceServiceReceiver receiver, String opPackageName) {
+        mHandler.post(() -> {
+            if (getDaemon() == null) {
+                bindFaceAuthService(mCurrentUserId);
+                try {
+                    receiver.onError(1, 0);
+                } catch (RemoteException e) {
+                    e.printStackTrace();
+                }
+            } else {
+                scheduleUpdateActiveUserWithoutHandler(userId);
+                mScheduler.scheduleClientMonitor(new FaceRemovalClient(mContext, mLazyDaemon, token, new ClientMonitorCallbackConverter(receiver), 0, userId, opPackageName, FaceUtils.getLegacyInstance(mSensorId), mSensorId, createLogger(BiometricsProtoEnums.ACTION_REMOVE, BiometricsProtoEnums.CLIENT_UNKNOWN), mBiometricContext, mAuthenticatorIds));
+            }
+        });
+    }
+
+    @Override
+    public void scheduleResetLockout(int sensorId, int userId, byte[] hardwareAuthToken) {
+        mHandler.post(() -> {
+            if (getDaemon() == null) {
+                bindFaceAuthService(mCurrentUserId);
+            } else if (getEnrolledFaces(sensorId, userId).isEmpty()) {
+                Slog.w(TAG, "Ignoring lockout reset, no templates enrolled for user: " + userId);
+            } else {
+                scheduleUpdateActiveUserWithoutHandler(userId);
+                mScheduler.scheduleClientMonitor(new FaceResetLockoutClient(mContext, mLazyDaemon, userId, mContext.getOpPackageName(), mSensorId, createLogger(BiometricsProtoEnums.ACTION_UNKNOWN, BiometricsProtoEnums.CLIENT_UNKNOWN), mBiometricContext, hardwareAuthToken));
+            }
+        });
+    }
+
+    @Override
+    public void scheduleSetFeature(int sensorId, IBinder token, int userId, int feature, boolean enabled, byte[] hardwareAuthToken, IFaceServiceReceiver receiver, String opPackageName) {
+        mHandler.post(() -> {
+            if (getDaemon() == null) {
+                bindFaceAuthService(mCurrentUserId);
+                return;
+            }
+            List<Face> faces = getEnrolledFaces(sensorId, userId);
+            if (faces.isEmpty()) {
+                Slog.w(TAG, "Ignoring setFeature, no templates enrolled for user: " + userId);
+                return;
+            }
+            scheduleUpdateActiveUserWithoutHandler(userId);
+            mScheduler.scheduleClientMonitor(new FaceSetFeatureClient(mContext, mLazyDaemon, token, new ClientMonitorCallbackConverter(receiver), userId, opPackageName, mSensorId, BiometricLogger.ofUnknown(mContext), mBiometricContext, feature, enabled, hardwareAuthToken, faces.get(0).getBiometricId()));
+        });
+    }
+
+    @Override
+    public void scheduleGetFeature(int sensorId, IBinder token, int userId, int feature, ClientMonitorCallbackConverter listener, String opPackageName) {
+        mHandler.post(() -> {
+            if (getDaemon() == null) {
+                bindFaceAuthService(mCurrentUserId);
+                if (listener != null) {
+                    try {
+                        listener.onError(DEVICE_ID, 0, 1, 0);
+                    } catch (RemoteException e) {
+                        e.printStackTrace();
+                    }
+                }
+            } else {
+                List<Face> faces = getEnrolledFaces(sensorId, userId);
+                if (faces.isEmpty()) {
+                    Slog.w(TAG, "Ignoring getFeature, no templates enrolled for user: " + userId);
+                    return;
+                }
+                scheduleUpdateActiveUserWithoutHandler(userId);
+                final FaceGetFeatureClient client = new FaceGetFeatureClient(mContext, mLazyDaemon, token, listener, userId, opPackageName, mSensorId, BiometricLogger.ofUnknown(mContext), mBiometricContext, feature, faces.get(0).getBiometricId());
+                mScheduler.scheduleClientMonitor(client, new ClientMonitorCallback() {
+                    @Override
+                    public void onClientFinished(BaseClientMonitor clientMonitor, boolean success) {
+                        if (success && feature == 1) {
+                            final int settingsValue = client.getValue() ? 1 : 0;
+                            Slog.d(TAG, "Updating attention value for user: " + userId + " to value: " + settingsValue);
+                            Settings.Secure.putIntForUser(mContext.getContentResolver(), "face_unlock_attention_required", settingsValue, userId);
+                        }
+                    }
+                });
+            }
+        });
+    }
+
+    void scheduleInternalCleanup(int userId, ClientMonitorCallback callback) {
+        mHandler.post(() -> {
+            scheduleUpdateActiveUserWithoutHandler(userId);
+            List<Face> enrolledList = getEnrolledFaces(mSensorId, userId);
+            String opPackageName = mContext.getOpPackageName();
+            mScheduler.scheduleClientMonitor(new FaceInternalCleanupClient(mContext, mLazyDaemon, userId, opPackageName, mSensorId, createLogger(BiometricsProtoEnums.ACTION_ENUMERATE, BiometricsProtoEnums.CLIENT_UNKNOWN), mBiometricContext, enrolledList, FaceUtils.getLegacyInstance(mSensorId), mAuthenticatorIds), callback);
+        });
+    }
+
+    @Override
+    public void scheduleInternalCleanup(int sensorId, int userId, ClientMonitorCallback callback) {
+        scheduleInternalCleanup(userId, callback);
+    }
+
+    @Override
+    public void scheduleInvalidateAuthenticatorId(int i, int i1, IInvalidationCallback iInvalidationCallback) {
+        ServiceProvider.super.scheduleInvalidateAuthenticatorId(i, i1, iInvalidationCallback);
+    }
+
+    @Override
+    public void startPreparedClient(int sensorId, int cookie) {
+        mHandler.post(() -> mScheduler.startPreparedClient(cookie));
+    }
+
+    @Override
+    public void dumpProtoState(int sensorId, ProtoOutputStream proto, boolean clearSchedulerBuffer) {
+        final long sensorToken = proto.start(SensorServiceStateProto.SENSOR_STATES);
+
+        proto.write(SensorStateProto.SENSOR_ID, mSensorProperties.sensorId);
+        proto.write(SensorStateProto.MODALITY, SensorStateProto.FACE);
+        proto.write(SensorStateProto.CURRENT_STRENGTH,
+                Utils.getCurrentStrength(mSensorProperties.sensorId));
+        proto.write(SensorStateProto.SCHEDULER, mScheduler.dumpProtoState(clearSchedulerBuffer));
+
+        for (UserInfo user : UserManager.get(mContext).getUsers()) {
+            final int userId = user.getUserHandle().getIdentifier();
+
+            final long userToken = proto.start(SensorStateProto.USER_STATES);
+            proto.write(UserStateProto.USER_ID, userId);
+            proto.write(UserStateProto.NUM_ENROLLED, FaceUtils.getLegacyInstance(mSensorId)
+                    .getBiometricsForUser(mContext, userId).size());
+            proto.end(userToken);
+        }
+
+        proto.write(SensorStateProto.RESET_LOCKOUT_REQUIRES_HARDWARE_AUTH_TOKEN,
+                mSensorProperties.resetLockoutRequiresHardwareAuthToken);
+        proto.write(SensorStateProto.RESET_LOCKOUT_REQUIRES_CHALLENGE,
+                mSensorProperties.resetLockoutRequiresChallenge);
+
+        proto.end(sensorToken);
+    }
+
+    @Override
+    public void dumpProtoMetrics(int sensorId, FileDescriptor fd) {
+    }
+
+    @Override
+    public void dumpInternal(int sensorId, PrintWriter pw) {
+        PerformanceTracker performanceTracker =
+                PerformanceTracker.getInstanceForSensorId(mSensorId);
+
+        JSONObject dump = new JSONObject();
+        try {
+            dump.put("service", TAG);
+
+            JSONArray sets = new JSONArray();
+            for (UserInfo user : UserManager.get(mContext).getUsers()) {
+                final int userId = user.getUserHandle().getIdentifier();
+                final int c = FaceUtils.getLegacyInstance(mSensorId)
+                        .getBiometricsForUser(mContext, userId).size();
+                JSONObject set = new JSONObject();
+                set.put("id", userId);
+                set.put("count", c);
+                set.put("accept", performanceTracker.getAcceptForUser(userId));
+                set.put("reject", performanceTracker.getRejectForUser(userId));
+                set.put("acquire", performanceTracker.getAcquireForUser(userId));
+                set.put("lockout", performanceTracker.getTimedLockoutForUser(userId));
+                set.put("permanentLockout", performanceTracker.getPermanentLockoutForUser(userId));
+                // cryptoStats measures statistics about secure face transactions
+                // (e.g. to unlock password storage, make secure purchases, etc.)
+                set.put("acceptCrypto", performanceTracker.getAcceptCryptoForUser(userId));
+                set.put("rejectCrypto", performanceTracker.getRejectCryptoForUser(userId));
+                set.put("acquireCrypto", performanceTracker.getAcquireCryptoForUser(userId));
+                sets.put(set);
+            }
+
+            dump.put("prints", sets);
+        } catch (JSONException e) {
+            Slog.e(TAG, "dump formatting failure", e);
+        }
+        pw.println(dump);
+        pw.println("HAL deaths since last reboot: " + performanceTracker.getHALDeathCount());
+
+        mScheduler.dump(pw);
+        mUsageStats.print(pw);
+    }
+
+    private void scheduleLoadAuthenticatorIds() {
+        mHandler.post(() -> {
+            for (UserInfo user : UserManager.get(mContext).getAliveUsers()) {
+                int targetUserId = user.id;
+                if (!mAuthenticatorIds.containsKey(Integer.valueOf(targetUserId))) {
+                    scheduleUpdateActiveUserWithoutHandler(targetUserId);
+                }
+            }
+        });
+    }
+
+    void scheduleUpdateActiveUserWithoutHandler(final int targetUserId) {
+        mScheduler.scheduleClientMonitor(new FaceUpdateActiveUserClient(mContext, mLazyDaemon, targetUserId, mContext.getOpPackageName(), mSensorId, createLogger(BiometricsProtoEnums.ACTION_UNKNOWN, BiometricsProtoEnums.CLIENT_UNKNOWN), mBiometricContext, mCurrentUserId, !getEnrolledFaces(mSensorId, targetUserId).isEmpty(), mAuthenticatorIds), new ClientMonitorCallback() {
+            @Override
+            public void onClientFinished(BaseClientMonitor clientMonitor, boolean success) {
+                if (success) {
+                    mCurrentUserId = targetUserId;
+                }
+            }
+        });
+    }
+
+    private boolean isFaceServiceEnabled() {
+        if (!FaceUnlockUtils.isFaceUnlockSupported()) {
+            return false;
+        }
+        PackageManager pm = mContext.getPackageManager();
+        ResolveInfo info = pm.resolveService(FaceUnlockUtils.getServiceIntent(), 131072);
+        return info != null && info.serviceInfo.isEnabled();
+    }
+
+    public static boolean useCustomFaceUnlockService() {
+        return FaceUnlockUtils.isFaceUnlockSupported();
+    }
+
+    private IFaceService getFaceService(int userId) {
+        if (userId == -10000) {
+            scheduleUpdateActiveUserWithoutHandler(ActivityManager.getCurrentUser());
+        }
+        return mFaceServices.get(mCurrentUserId);
+    }
+
+    void bindFaceAuthService(int userId) {
+        Slog.d(TAG, "bindFaceAuthService " + userId);
+        if (!isFaceServiceEnabled()) {
+            Slog.d(TAG, "FaceService disabled");
+        } else if (mIsServiceBinding) {
+            Slog.d(TAG, "FaceService is binding");
+        } else {
+            if (userId != -10000 && getFaceService(userId) == null) {
+                try {
+                    Intent intent = FaceUnlockUtils.getServiceIntent();
+                    boolean result = mContext.bindServiceAsUser(intent, new FaceServiceConnection(userId), 1, UserHandle.of(userId));
+                    if (result) {
+                        mIsServiceBinding = true;
+                    }
+                } catch (SecurityException e) {
+                    e.printStackTrace();
+                }
+            }
+        }
+    }
+
+    @Override
+    public void dumpHal(int sensorId, FileDescriptor fd, String[] args) {
+    }
+
+    protected void setTestHalEnabled(boolean enabled) {
+        mTestHalEnabled = enabled;
+    }
+
+    @Override
+    public ITestSession createTestSession(int sensorId, ITestSessionCallback callback, String opPackageName) {
+        return new BiometricTestSessionImpl(mContext, mSensorId, callback, this, mHalResultController);
+    }
+
+    public static class HalResultController extends com.android.internal.util.custom.faceunlock.IFaceServiceReceiver.Stub {
+        private final Context mContext;
+        private final Handler mHandler;
+        private final LockoutResetDispatcher mLockoutResetDispatcher;
+        private final LockoutHalImpl mLockoutTracker;
+        private final BiometricScheduler mScheduler;
+        private final int mSensorId;
+        private Callback mCallback;
+
+        HalResultController(int sensorId, Context context, Handler handler, BiometricScheduler scheduler, LockoutHalImpl lockoutTracker, LockoutResetDispatcher lockoutResetDispatcher) {
+            mSensorId = sensorId;
+            mContext = context;
+            mHandler = handler;
+            mScheduler = scheduler;
+            mLockoutTracker = lockoutTracker;
+            mLockoutResetDispatcher = lockoutResetDispatcher;
+        }
+
+        public void setCallback(Callback callback) {
+            mCallback = callback;
+        }
+
+        public void onEnrollResult(int faceId, int userId, int remaining) {
+            mHandler.post(() -> {
+                Face face = new Face(FaceUtils.getLegacyInstance(mSensorId).getUniqueName(mContext, userId), faceId, DEVICE_ID);
+                BaseClientMonitor client = mScheduler.getCurrentClient();
+                if (!(client instanceof FaceEnrollClient)) {
+                    Slog.e(TAG, "onEnrollResult for non-enroll client: " + Utils.getClientName(client));
+                    return;
+                }
+                ((FaceEnrollClient) client).onEnrollResult(face, remaining);
+            });
+        }
+
+        public void onAuthenticated(int faceId, int userId, byte[] token) {
+            mHandler.post(() -> {
+                BaseClientMonitor client = mScheduler.getCurrentClient();
+                if (!(client instanceof AuthenticationConsumer)) {
+                    Slog.e(TAG, "onAuthenticated for non-authentication consumer: " + Utils.getClientName(client));
+                    return;
+                }
+                ((AuthenticationConsumer) client).onAuthenticated(new Face("", faceId, DEVICE_ID), faceId != 0, ArrayUtils.toByteArrayList(token));
+            });
+        }
+
+        public void onAcquired(int userId, int acquiredInfo, int vendorCode) {
+            mHandler.post(() -> {
+                BaseClientMonitor client = mScheduler.getCurrentClient();
+                if (!(client instanceof AcquisitionClient)) {
+                    Slog.e(TAG, "onAcquired for non-acquire client: " + Utils.getClientName(client));
+                    return;
+                }
+                final AcquisitionClient<?> acquisitionClient =
+                        (AcquisitionClient<?>) client;
+                acquisitionClient.onAcquired(acquiredInfo, vendorCode);
+            });
+        }
+
+        public void onError(int error, int vendorCode) {
+            mHandler.post(() -> {
+                BaseClientMonitor client = mScheduler.getCurrentClient();
+                String log = "handleError, client: " +
+                        (client != null ? client.getOwnerString() : null) +
+                        ", error: " +
+                        error +
+                        ", vendorCode: " +
+                        vendorCode;
+                Slog.d(TAG, log);
+                if (!(client instanceof ErrorConsumer)) {
+                    Slog.e(TAG, "onError for non-error consumer: " + Utils.getClientName(client));
+                    return;
+                }
+                ((ErrorConsumer) client).onError(error, vendorCode);
+                if (error == 1) {
+                    Slog.e(TAG, "Got ERROR_HW_UNAVAILABLE");
+                    if (mCallback != null) {
+                        mCallback.onHardwareUnavailable();
+                    }
+                }
+            });
+        }
+
+        public void onRemoved(int[] removed, int userId) {
+            mHandler.post(() -> {
+                BaseClientMonitor client = mScheduler.getCurrentClient();
+                if (!(client instanceof RemovalConsumer)) {
+                    Slog.e(TAG, "onRemoved for non-removal consumer: " + Utils.getClientName(client));
+                    return;
+                }
+                RemovalConsumer removalConsumer = (RemovalConsumer) client;
+                if (removed.length > 0) {
+                    for (int i = 0; i < removed.length; i++) {
+                        int id = removed[i];
+                        Face face = new Face("", id, DEVICE_ID);
+                        int remaining = (removed.length - i) - 1;
+                        Slog.d(TAG, "Removed, faceId: " + id + ", remaining: " + remaining);
+                        removalConsumer.onRemoved(face, remaining);
+                    }
+                } else {
+                    removalConsumer.onRemoved(null, 0);
+                }
+                Settings.Secure.putIntForUser(mContext.getContentResolver(), "face_unlock_re_enroll", 0, -2);
+            });
+        }
+
+        public void onEnumerate(int[] faceIds, int userId) {
+            mHandler.post(() -> {
+                BaseClientMonitor client = mScheduler.getCurrentClient();
+                if (!(client instanceof EnumerateConsumer)) {
+                    Slog.e(TAG, "onEnumerate for non-enumerate consumer: " + Utils.getClientName(client));
+                    return;
+                }
+                EnumerateConsumer enumerateConsumer = (EnumerateConsumer) client;
+                if (faceIds.length > 0) {
+                    for (int i = 0; i < faceIds.length; i++) {
+                        enumerateConsumer.onEnumerationResult(new Face("", faceIds[i], DEVICE_ID), (faceIds.length - i) - 1);
+                    }
+                    return;
+                }
+                enumerateConsumer.onEnumerationResult(null, 0);
+            });
+        }
+
+        public void onLockoutChanged(long duration) {
+            mHandler.post(() -> {
+                int lockoutMode;
+                Slog.d(TAG, "onLockoutChanged: " + duration);
+                if (duration == 0) {
+                    lockoutMode = 0;
+                } else if (duration == -1 || duration == Long.MAX_VALUE) {
+                    lockoutMode = 2;
+                } else {
+                    lockoutMode = 1;
+                }
+                mLockoutTracker.setCurrentUserLockoutMode(lockoutMode);
+                if (duration == 0) {
+                    mLockoutResetDispatcher.notifyLockoutResetCallbacks(mSensorId);
+                }
+            });
+        }
+
+        public interface Callback {
+            void onHardwareUnavailable();
+        }
+    }
+
+    class FaceServiceConnection implements ServiceConnection {
+        private final int mUserId;
+
+        public FaceServiceConnection(int userId) {
+            mUserId = userId;
+        }
+
+        @Override
+        public void onServiceConnected(ComponentName className, IBinder service) {
+            Slog.d(TAG, "FaceService connected : " + mUserId);
+            IFaceService faceService = IFaceService.Stub.asInterface(service);
+            if (faceService != null) {
+                synchronized (mFaceServices) {
+                    try {
+                        faceService.setCallback(mHalResultController);
+                        mFaceServices.put(mUserId, faceService);
+                        mHandler.post(() -> {
+                            scheduleInternalCleanup(mUserId, null);
+                            scheduleGetFeature(mSensorId, new Binder(), mUserId, 1, null, mContext.getOpPackageName());
+                        });
+                    } catch (RemoteException e) {
+                        e.printStackTrace();
+                    }
+                    mIsServiceBinding = false;
+                }
+            }
+        }
+
+        @Override
+        public void onServiceDisconnected(ComponentName className) {
+            Slog.d(TAG, "FaceService disconnected : " + mUserId);
+            mFaceServices.remove(mUserId);
+            mIsServiceBinding = false;
+            if (mUserId == mCurrentUserId) {
+                mHandler.postDelayed(() -> {
+                    BaseClientMonitor client = mScheduler.getCurrentClient();
+                    if (client instanceof ErrorConsumer) {
+                        ((ErrorConsumer) client).onError(5, 0);
+                    }
+                    bindFaceAuthService(mUserId);
+                    mScheduler.recordCrashState();
+                    mScheduler.reset();
+                }, 100);
+            }
+            mContext.unbindService(this);
+        }
+    }
+
+    private BiometricLogger createLogger(int statsAction, int statsClient) {
+        return new BiometricLogger(mContext, BiometricsProtoEnums.MODALITY_FACE,
+                statsAction, statsClient);
+    }
+}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceAuthenticationClient.java b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceAuthenticationClient.java
new file mode 100644
index 000000000000..5c01d7b20f6a
--- /dev/null
+++ b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceAuthenticationClient.java
@@ -0,0 +1,141 @@
+/*
+* Copyright (C) 2022 The Pixel Experience Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package com.android.server.biometrics.sensors.face.custom;
+
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.res.Resources;
+import android.hardware.biometrics.BiometricAuthenticator;
+import android.os.IBinder;
+import android.os.RemoteException;
+import android.provider.Settings;
+import android.util.Slog;
+
+import com.android.internal.R;
+import com.android.internal.util.custom.faceunlock.IFaceService;
+import com.android.server.biometrics.Utils;
+import com.android.server.biometrics.sensors.AuthenticationClient;
+import com.android.server.biometrics.sensors.BiometricNotificationUtils;
+import com.android.server.biometrics.sensors.ClientMonitorCallbackConverter;
+import com.android.server.biometrics.sensors.LockoutTracker;
+import com.android.server.biometrics.sensors.face.UsageStats;
+import com.android.server.biometrics.log.BiometricContext;
+import com.android.server.biometrics.log.BiometricLogger;
+
+import java.util.ArrayList;
+import java.util.function.Supplier;
+
+class FaceAuthenticationClient extends AuthenticationClient<IFaceService> {
+    private static final String TAG = "FaceAuthenticationClient";
+    private final int[] mBiometricPromptIgnoreList;
+    private final int[] mBiometricPromptIgnoreListVendor;
+    private final ContentResolver mContentResolver;
+    private final boolean mCustomHaptics;
+    private final int[] mKeyguardIgnoreList;
+    private final int[] mKeyguardIgnoreListVendor;
+    private final UsageStats mUsageStats;
+    private int mLastAcquire;
+
+    FaceAuthenticationClient(Context context, Supplier<IFaceService> lazyDaemon, IBinder token, long requestId, ClientMonitorCallbackConverter listener, int targetUserId, long operationId, boolean restricted, String owner, int cookie, boolean requireConfirmation, int sensorId, BiometricLogger biometricLogger, BiometricContext biometricContext, boolean isStrongBiometric, LockoutTracker lockoutTracker, UsageStats usageStats, boolean allowBackgroundAuthentication) {
+        super(context, lazyDaemon, token, listener, targetUserId, operationId, restricted, owner, cookie, requireConfirmation, sensorId, biometricLogger, biometricContext, isStrongBiometric, null /* taskStackListener */, lockoutTracker, allowBackgroundAuthentication, true, false);
+        mUsageStats = usageStats;
+        setRequestId(requestId);
+        Resources resources = getContext().getResources();
+        mBiometricPromptIgnoreList = resources.getIntArray(
+                R.array.config_face_acquire_biometricprompt_ignorelist);
+        mBiometricPromptIgnoreListVendor = resources.getIntArray(
+                R.array.config_face_acquire_vendor_biometricprompt_ignorelist);
+        mKeyguardIgnoreList = resources.getIntArray(
+                R.array.config_face_acquire_keyguard_ignorelist);
+        mKeyguardIgnoreListVendor = resources.getIntArray(
+                R.array.config_face_acquire_vendor_keyguard_ignorelist);
+        ContentResolver contentResolver = context.getContentResolver();
+        mContentResolver = contentResolver;
+        mCustomHaptics = Settings.Global.getInt(contentResolver, "face_custom_success_error", 0) == 1;
+    }
+
+    @Override
+    protected void startHalOperation() {
+        try {
+            getFreshDaemon().authenticate(mOperationId);
+        } catch (RemoteException e) {
+            Slog.e(TAG, "Remote exception when requesting auth", e);
+            onError(1, 0);
+            mCallback.onClientFinished(this, false);
+        }
+    }
+
+    @Override
+    protected void handleLifecycleAfterAuth(boolean authenticated) {
+    }
+
+    @Override
+    protected void stopHalOperation() {
+        try {
+            getFreshDaemon().cancel();
+        } catch (RemoteException e) {
+            Slog.e(TAG, "Remote exception when requesting cancel", e);
+            onError(1, 0);
+            mCallback.onClientFinished(this, false);
+        }
+    }
+
+    @Override
+    public boolean wasUserDetected() {
+        return mLastAcquire != 11 && mLastAcquire != 21;
+    }
+
+    @Override
+    public void onAuthenticated(BiometricAuthenticator.Identifier identifier, boolean authenticated, ArrayList<Byte> token) {
+        super.onAuthenticated(identifier, authenticated, token);
+        mUsageStats.addEvent(new UsageStats.AuthenticationEvent(getStartTimeMs(), System.currentTimeMillis() - getStartTimeMs(), authenticated, 0, 0, getTargetUserId()));
+        mCallback.onClientFinished(this, true);
+    }
+
+    @Override
+    public void onError(int error, int vendorCode) {
+        mUsageStats.addEvent(new UsageStats.AuthenticationEvent(getStartTimeMs(), System.currentTimeMillis() - getStartTimeMs(), false, error, vendorCode, getTargetUserId()));
+        if (error == 16) {
+            BiometricNotificationUtils.showReEnrollmentNotification(getContext());
+        }
+        super.onError(error, vendorCode);
+    }
+
+    private int[] getAcquireIgnorelist() {
+        return isBiometricPrompt() ? mBiometricPromptIgnoreList : mKeyguardIgnoreList;
+    }
+
+    private int[] getAcquireVendorIgnorelist() {
+        return isBiometricPrompt() ? mBiometricPromptIgnoreListVendor : mKeyguardIgnoreListVendor;
+    }
+
+    private boolean shouldSend(int acquireInfo, int vendorCode) {
+        if (acquireInfo == 22) {
+            return !Utils.listContains(getAcquireVendorIgnorelist(), vendorCode);
+        }
+        return !Utils.listContains(getAcquireIgnorelist(), acquireInfo);
+    }
+
+    @Override
+    public void onAcquired(int acquireInfo, int vendorCode) {
+        mLastAcquire = acquireInfo;
+        if (acquireInfo == 13) {
+            BiometricNotificationUtils.showReEnrollmentNotification(getContext());
+        }
+        onAcquiredInternal(acquireInfo, vendorCode, shouldSend(acquireInfo, vendorCode));
+    }
+}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceEnrollClient.java b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceEnrollClient.java
new file mode 100644
index 000000000000..6272ce7ec32c
--- /dev/null
+++ b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceEnrollClient.java
@@ -0,0 +1,101 @@
+/*
+* Copyright (C) 2022 The Pixel Experience Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package com.android.server.biometrics.sensors.face.custom;
+
+import android.content.Context;
+import android.hardware.face.Face;
+import android.os.IBinder;
+import android.os.RemoteException;
+import android.util.Slog;
+import android.view.Surface;
+
+import com.android.internal.R;
+import com.android.internal.util.custom.faceunlock.IFaceService;
+import com.android.server.biometrics.Utils;
+import com.android.server.biometrics.sensors.BiometricUtils;
+import com.android.server.biometrics.sensors.ClientMonitorCallbackConverter;
+import com.android.server.biometrics.sensors.EnrollClient;
+import com.android.server.biometrics.log.BiometricContext;
+import com.android.server.biometrics.log.BiometricLogger;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.function.Supplier;
+
+class FaceEnrollClient extends EnrollClient<IFaceService> {
+    private static final String TAG = "FaceEnrollClient";
+    private final int[] mDisabledFeatures;
+    private final int[] mEnrollIgnoreList = getContext().getResources().getIntArray(R.array.config_face_acquire_enroll_ignorelist);
+    private final int[] mEnrollIgnoreListVendor = getContext().getResources().getIntArray(R.array.config_face_acquire_vendor_enroll_ignorelist);
+    private final Surface mPreviewSurface;
+
+    FaceEnrollClient(Context context, Supplier<IFaceService> lazyDaemon, IBinder token, ClientMonitorCallbackConverter listener, int userId, byte[] hardwareAuthToken, String owner, BiometricUtils<Face> utils, int[] disabledFeatures, int timeoutSec, Surface previewSurface, int sensorId, BiometricLogger biometricLogger, BiometricContext biometricContext) {
+        super(context, lazyDaemon, token, listener, userId, hardwareAuthToken, owner, utils, timeoutSec, sensorId, false /* shouldVibrate */, biometricLogger, biometricContext);
+        mDisabledFeatures = Arrays.copyOf(disabledFeatures, disabledFeatures.length);
+        mPreviewSurface = previewSurface;
+    }
+
+    @Override
+    protected boolean hasReachedEnrollmentLimit() {
+        if (mBiometricUtils.getBiometricsForUser(getContext(), getTargetUserId()).size() < getContext().getResources().getInteger(R.integer.config_faceMaxTemplatesPerUser)) {
+            return false;
+        }
+        Slog.w(TAG, "Too many faces registered, user: " + getTargetUserId());
+        return true;
+    }
+
+    @Override
+    public void onAcquired(int acquireInfo, int vendorCode) {
+        boolean shouldSend;
+        if (acquireInfo == 22) {
+            shouldSend = !Utils.listContains(mEnrollIgnoreListVendor, vendorCode);
+        } else {
+            shouldSend = !Utils.listContains(mEnrollIgnoreList, acquireInfo);
+        }
+        onAcquiredInternal(acquireInfo, vendorCode, shouldSend);
+    }
+
+    @Override
+    protected void startHalOperation() {
+        ArrayList<Byte> token = new ArrayList<>();
+        for (byte b : mHardwareAuthToken) {
+            token.add(b);
+        }
+        ArrayList<Integer> disabledFeatures = new ArrayList<>();
+        for (int disabledFeature : mDisabledFeatures) {
+            disabledFeatures.add(disabledFeature);
+        }
+        try {
+            getFreshDaemon().enroll(ArrayUtils.toByteArray(token), mTimeoutSec, ArrayUtils.toIntArray(disabledFeatures));
+        } catch (RemoteException e) {
+            Slog.e(TAG, "Remote exception when requesting enroll", e);
+            onError(2, 0);
+            mCallback.onClientFinished(this, false);
+        }
+    }
+
+    @Override
+    protected void stopHalOperation() {
+        try {
+            getFreshDaemon().cancel();
+        } catch (RemoteException e) {
+            Slog.e(TAG, "Remote exception when requesting cancel", e);
+            onError(1, 0);
+            mCallback.onClientFinished(this, false);
+        }
+    }
+}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceGenerateChallengeClient.java b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceGenerateChallengeClient.java
new file mode 100644
index 000000000000..44c4e6809c07
--- /dev/null
+++ b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceGenerateChallengeClient.java
@@ -0,0 +1,94 @@
+/*
+* Copyright (C) 2022 The Pixel Experience Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package com.android.server.biometrics.sensors.face.custom;
+
+import android.content.Context;
+import android.hardware.face.IFaceServiceReceiver;
+import android.os.IBinder;
+import android.os.RemoteException;
+import android.util.Slog;
+
+import com.android.internal.util.Preconditions;
+import com.android.internal.util.custom.faceunlock.IFaceService;
+import com.android.server.biometrics.sensors.BaseClientMonitor;
+import com.android.server.biometrics.sensors.ClientMonitorCallback;
+import com.android.server.biometrics.sensors.ClientMonitorCallbackConverter;
+import com.android.server.biometrics.sensors.GenerateChallengeClient;
+import com.android.server.biometrics.log.BiometricContext;
+import com.android.server.biometrics.log.BiometricLogger;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.function.Supplier;
+
+class FaceGenerateChallengeClient extends GenerateChallengeClient<IFaceService> {
+    static final int CHALLENGE_TIMEOUT_SEC = 600;
+    private static final ClientMonitorCallback EMPTY_CALLBACK = new ClientMonitorCallback() {
+    };
+    private static final String TAG = "FaceGenerateChallengeClient";
+    private final long mCreatedAt;
+    private Long mChallengeResult;
+    private List<IFaceServiceReceiver> mWaiting = new ArrayList();
+
+    FaceGenerateChallengeClient(Context context, Supplier<IFaceService> lazyDaemon, IBinder token, ClientMonitorCallbackConverter listener, int userId, String owner, int sensorId, BiometricLogger biometricLogger, BiometricContext biometricContext, long now) {
+        super(context, lazyDaemon, token, listener, userId, owner, sensorId, biometricLogger, biometricContext);
+        mCreatedAt = now;
+    }
+
+    @Override
+    protected void startHalOperation() {
+        mChallengeResult = null;
+        try {
+            try {
+                mChallengeResult = getFreshDaemon().generateChallenge(600);
+                sendChallengeResult(getListener(), mCallback);
+                for (IFaceServiceReceiver receiver : mWaiting) {
+                    sendChallengeResult(new ClientMonitorCallbackConverter(receiver), EMPTY_CALLBACK);
+                }
+            } catch (RemoteException e) {
+                Slog.e(TAG, "generateChallenge failed", e);
+                mCallback.onClientFinished(this, false);
+            }
+        } finally {
+            mWaiting = null;
+        }
+    }
+
+    public long getCreatedAt() {
+        return mCreatedAt;
+    }
+
+    public void reuseResult(IFaceServiceReceiver receiver) {
+        List<IFaceServiceReceiver> list = mWaiting;
+        if (list != null) {
+            list.add(receiver);
+        } else {
+            sendChallengeResult(new ClientMonitorCallbackConverter(receiver), EMPTY_CALLBACK);
+        }
+    }
+
+    private void sendChallengeResult(ClientMonitorCallbackConverter receiver, ClientMonitorCallback ownerCallback) {
+        Preconditions.checkState(mChallengeResult != null, "result not available");
+        try {
+            receiver.onChallengeGenerated(getSensorId(), getTargetUserId(), mChallengeResult);
+            ownerCallback.onClientFinished(this, true);
+        } catch (RemoteException e) {
+            Slog.e(TAG, "Remote exception", e);
+            ownerCallback.onClientFinished(this, false);
+        }
+    }
+}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceGetFeatureClient.java b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceGetFeatureClient.java
new file mode 100644
index 000000000000..901bf581fa13
--- /dev/null
+++ b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceGetFeatureClient.java
@@ -0,0 +1,88 @@
+/*
+* Copyright (C) 2022 The Pixel Experience Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package com.android.server.biometrics.sensors.face.custom;
+
+import android.content.Context;
+import android.os.IBinder;
+import android.os.RemoteException;
+import android.util.Slog;
+
+import com.android.internal.util.custom.faceunlock.IFaceService;
+import com.android.server.biometrics.sensors.BaseClientMonitor;
+import com.android.server.biometrics.sensors.ClientMonitorCallback;
+import com.android.server.biometrics.sensors.ClientMonitorCallbackConverter;
+import com.android.server.biometrics.sensors.HalClientMonitor;
+import com.android.server.biometrics.log.BiometricContext;
+import com.android.server.biometrics.log.BiometricLogger;
+
+import java.util.function.Supplier;
+
+public class FaceGetFeatureClient extends HalClientMonitor<IFaceService> {
+    private static final String TAG = "FaceGetFeatureClient";
+    private final int mFaceId;
+    private final int mFeature;
+    private boolean mValue;
+
+    FaceGetFeatureClient(Context context, Supplier<IFaceService> lazyDaemon, IBinder token, ClientMonitorCallbackConverter listener, int userId, String owner, int sensorId, BiometricLogger biometricLogger, BiometricContext biometricContext, int feature, int faceId) {
+        super(context, lazyDaemon, token, listener, userId, owner, 0, sensorId, biometricLogger, biometricContext);
+        mFeature = feature;
+        mFaceId = faceId;
+    }
+
+    @Override
+    public void unableToStart() {
+        try {
+            if (getListener() != null) {
+                getListener().onFeatureGet(false, new int[0], new boolean[0]);
+            }
+        } catch (RemoteException e) {
+            Slog.e(TAG, "Unable to send error", e);
+        }
+    }
+
+    @Override
+    public void start(ClientMonitorCallback callback) {
+        super.start(callback);
+        startHalOperation();
+    }
+
+    @Override
+    protected void startHalOperation() {
+        try {
+            boolean result = getFreshDaemon().getFeature(mFeature, mFaceId);
+            int[] features = {mFeature};
+            boolean[] featureState = {result};
+            mValue = result;
+            if (getListener() != null) {
+                getListener().onFeatureGet(result, features, featureState);
+            }
+            mCallback.onClientFinished(this, true);
+        } catch (RemoteException e) {
+            Slog.e(TAG, "Unable to getFeature", e);
+            mCallback.onClientFinished(this, false);
+        }
+    }
+
+    public boolean getValue() {
+        return mValue;
+    }
+
+    @Override
+    public int getProtoEnum() {
+        return 9;
+    }
+}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceInternalCleanupClient.java b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceInternalCleanupClient.java
new file mode 100644
index 000000000000..662886d79ca5
--- /dev/null
+++ b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceInternalCleanupClient.java
@@ -0,0 +1,49 @@
+/*
+* Copyright (C) 2022 The Pixel Experience Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package com.android.server.biometrics.sensors.face.custom;
+
+import android.content.Context;
+import android.hardware.face.Face;
+import android.os.IBinder;
+
+import com.android.internal.util.custom.faceunlock.IFaceService;
+import com.android.server.biometrics.sensors.BiometricUtils;
+import com.android.server.biometrics.sensors.InternalCleanupClient;
+import com.android.server.biometrics.sensors.InternalEnumerateClient;
+import com.android.server.biometrics.sensors.RemovalClient;
+import com.android.server.biometrics.log.BiometricContext;
+import com.android.server.biometrics.log.BiometricLogger;
+
+import java.util.List;
+import java.util.Map;
+import java.util.function.Supplier;
+
+class FaceInternalCleanupClient extends InternalCleanupClient<Face, IFaceService> {
+    FaceInternalCleanupClient(Context context, Supplier<IFaceService> lazyDaemon, int userId, String owner, int sensorId, BiometricLogger biometricLogger, BiometricContext biometricContext, List<Face> enrolledList, BiometricUtils<Face> utils, Map<Integer, Long> authenticatorIds) {
+        super(context, lazyDaemon, userId, owner, sensorId, biometricLogger, biometricContext, enrolledList, utils, authenticatorIds);
+    }
+
+    @Override
+    protected InternalEnumerateClient<IFaceService> getEnumerateClient(Context context, Supplier<IFaceService> lazyDaemon, IBinder token, int userId, String owner, List<Face> enrolledList, BiometricUtils<Face> utils, int sensorId, BiometricLogger biometricLogger, BiometricContext biometricContext) {
+        return new FaceInternalEnumerateClient(context, lazyDaemon, token, userId, owner, enrolledList, utils, sensorId, biometricLogger, biometricContext);
+    }
+
+    @Override
+    protected RemovalClient<Face, IFaceService> getRemovalClient(Context context, Supplier<IFaceService> lazyDaemon, IBinder token, int biometricId, int userId, String owner, BiometricUtils<Face> utils, int sensorId, BiometricLogger biometricLogger, BiometricContext biometricContext, Map<Integer, Long> authenticatorIds) {
+        return new FaceRemovalClient(context, lazyDaemon, token, null, biometricId, userId, owner, utils, sensorId, biometricLogger, biometricContext, authenticatorIds);
+    }
+}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceInternalEnumerateClient.java b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceInternalEnumerateClient.java
new file mode 100644
index 000000000000..68b1d3b1f055
--- /dev/null
+++ b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceInternalEnumerateClient.java
@@ -0,0 +1,50 @@
+/*
+* Copyright (C) 2022 The Pixel Experience Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package com.android.server.biometrics.sensors.face.custom;
+
+import android.content.Context;
+import android.hardware.face.Face;
+import android.os.IBinder;
+import android.os.RemoteException;
+import android.util.Slog;
+
+import com.android.internal.util.custom.faceunlock.IFaceService;
+import com.android.server.biometrics.sensors.BiometricUtils;
+import com.android.server.biometrics.sensors.InternalEnumerateClient;
+import com.android.server.biometrics.log.BiometricContext;
+import com.android.server.biometrics.log.BiometricLogger;
+
+import java.util.List;
+import java.util.function.Supplier;
+
+class FaceInternalEnumerateClient extends InternalEnumerateClient<IFaceService> {
+    private static final String TAG = "FaceInternalEnumerateClient";
+
+    FaceInternalEnumerateClient(Context context, Supplier<IFaceService> lazyDaemon, IBinder token, int userId, String owner, List<Face> enrolledList, BiometricUtils<Face> utils, int sensorId, BiometricLogger biometricLogger, BiometricContext biometricContext) {
+        super(context, lazyDaemon, token, userId, owner, enrolledList, utils, sensorId, biometricLogger, biometricContext);
+    }
+
+    @Override
+    protected void startHalOperation() {
+        try {
+            getFreshDaemon().enumerate();
+        } catch (RemoteException e) {
+            Slog.e(TAG, "Remote exception when requesting enumerate", e);
+            mCallback.onClientFinished(this, false);
+        }
+    }
+}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceRemovalClient.java b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceRemovalClient.java
new file mode 100644
index 000000000000..61a7976fc0c6
--- /dev/null
+++ b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceRemovalClient.java
@@ -0,0 +1,53 @@
+/*
+* Copyright (C) 2022 The Pixel Experience Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package com.android.server.biometrics.sensors.face.custom;
+
+import android.content.Context;
+import android.hardware.face.Face;
+import android.os.IBinder;
+import android.os.RemoteException;
+import android.util.Slog;
+
+import com.android.internal.util.custom.faceunlock.IFaceService;
+import com.android.server.biometrics.sensors.BiometricUtils;
+import com.android.server.biometrics.sensors.ClientMonitorCallbackConverter;
+import com.android.server.biometrics.sensors.RemovalClient;
+import com.android.server.biometrics.log.BiometricContext;
+import com.android.server.biometrics.log.BiometricLogger;
+
+import java.util.Map;
+import java.util.function.Supplier;
+
+class FaceRemovalClient extends RemovalClient<Face, IFaceService> {
+    private static final String TAG = "FaceRemovalClient";
+    private final int mBiometricId;
+
+    FaceRemovalClient(Context context, Supplier<IFaceService> lazyDaemon, IBinder token, ClientMonitorCallbackConverter listener, int biometricId, int userId, String owner, BiometricUtils<Face> utils, int sensorId, BiometricLogger biometricLogger, BiometricContext biometricContext, Map<Integer, Long> authenticatorIds) {
+        super(context, lazyDaemon, token, listener, userId, owner, utils, sensorId, biometricLogger, biometricContext, authenticatorIds);
+        mBiometricId = biometricId;
+    }
+
+    @Override
+    protected void startHalOperation() {
+        try {
+            getFreshDaemon().remove(mBiometricId);
+        } catch (RemoteException e) {
+            Slog.e(TAG, "Remote exception when requesting remove", e);
+            mCallback.onClientFinished(this, false);
+        }
+    }
+}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceResetLockoutClient.java b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceResetLockoutClient.java
new file mode 100644
index 000000000000..5915f81056f5
--- /dev/null
+++ b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceResetLockoutClient.java
@@ -0,0 +1,71 @@
+/*
+* Copyright (C) 2022 The Pixel Experience Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package com.android.server.biometrics.sensors.face.custom;
+
+import android.content.Context;
+import android.os.RemoteException;
+import android.util.Slog;
+
+import com.android.internal.util.custom.faceunlock.IFaceService;
+import com.android.server.biometrics.sensors.BaseClientMonitor;
+import com.android.server.biometrics.sensors.ClientMonitorCallback;
+import com.android.server.biometrics.sensors.HalClientMonitor;
+import com.android.server.biometrics.log.BiometricContext;
+import com.android.server.biometrics.log.BiometricLogger;
+
+import java.util.function.Supplier;
+
+class FaceResetLockoutClient extends HalClientMonitor<IFaceService> {
+    private static final String TAG = "FaceResetLockoutClient";
+    private final byte[] mHardwareAuthToken;
+
+    FaceResetLockoutClient(Context context, Supplier<IFaceService> lazyDaemon, int userId, String owner, int sensorId, BiometricLogger biometricLogger, BiometricContext biometricContext, byte[] hardwareAuthToken) {
+        super(context, lazyDaemon, null, null, userId, owner, 0, sensorId, biometricLogger, biometricContext);
+        mHardwareAuthToken = hardwareAuthToken.clone();
+    }
+
+    @Override
+    public void unableToStart() {
+    }
+
+    @Override
+    public void start(ClientMonitorCallback callback) {
+        super.start(callback);
+        startHalOperation();
+    }
+
+    @Override
+    protected void startHalOperation() {
+        try {
+            getFreshDaemon().resetLockout(mHardwareAuthToken);
+            mCallback.onClientFinished(this, true);
+        } catch (RemoteException e) {
+            Slog.e(TAG, "Unable to reset lockout", e);
+            mCallback.onClientFinished(this, false);
+        }
+    }
+
+    @Override
+    public int getProtoEnum() {
+        return 12;
+    }
+
+    @Override
+    public boolean interruptsPrecedingClients() {
+        return true;
+    }
+}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceRevokeChallengeClient.java b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceRevokeChallengeClient.java
new file mode 100644
index 000000000000..7939bf3d75b1
--- /dev/null
+++ b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceRevokeChallengeClient.java
@@ -0,0 +1,48 @@
+/*
+* Copyright (C) 2022 The Pixel Experience Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package com.android.server.biometrics.sensors.face.custom;
+
+import android.content.Context;
+import android.os.IBinder;
+import android.os.RemoteException;
+import android.util.Slog;
+
+import com.android.internal.util.custom.faceunlock.IFaceService;
+import com.android.server.biometrics.sensors.RevokeChallengeClient;
+import com.android.server.biometrics.log.BiometricContext;
+import com.android.server.biometrics.log.BiometricLogger;
+
+import java.util.function.Supplier;
+
+class FaceRevokeChallengeClient extends RevokeChallengeClient<IFaceService> {
+    private static final String TAG = "FaceRevokeChallengeClient";
+
+    FaceRevokeChallengeClient(Context context, Supplier<IFaceService> lazyDaemon, IBinder token, int userId, String owner, int sensorId, BiometricLogger biometricLogger, BiometricContext biometricContext) {
+        super(context, lazyDaemon, token, userId, owner, sensorId, biometricLogger, biometricContext);
+    }
+
+    @Override
+    protected void startHalOperation() {
+        try {
+            getFreshDaemon().revokeChallenge();
+            mCallback.onClientFinished(this, true);
+        } catch (RemoteException e) {
+            Slog.e(TAG, "revokeChallenge failed", e);
+            mCallback.onClientFinished(this, false);
+        }
+    }
+}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceSetFeatureClient.java b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceSetFeatureClient.java
new file mode 100644
index 000000000000..174cfca92982
--- /dev/null
+++ b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceSetFeatureClient.java
@@ -0,0 +1,80 @@
+/*
+* Copyright (C) 2022 The Pixel Experience Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package com.android.server.biometrics.sensors.face.custom;
+
+import android.content.Context;
+import android.os.IBinder;
+import android.os.RemoteException;
+import android.util.Slog;
+
+import com.android.internal.util.custom.faceunlock.IFaceService;
+import com.android.server.biometrics.sensors.BaseClientMonitor;
+import com.android.server.biometrics.sensors.ClientMonitorCallback;
+import com.android.server.biometrics.sensors.ClientMonitorCallbackConverter;
+import com.android.server.biometrics.sensors.HalClientMonitor;
+import com.android.server.biometrics.log.BiometricContext;
+import com.android.server.biometrics.log.BiometricLogger;
+
+import java.util.function.Supplier;
+
+class FaceSetFeatureClient extends HalClientMonitor<IFaceService> {
+    private static final String TAG = "FaceSetFeatureClient";
+    private final boolean mEnabled;
+    private final int mFaceId;
+    private final int mFeature;
+    private final byte[] mHardwareAuthToken;
+
+    FaceSetFeatureClient(Context context, Supplier<IFaceService> lazyDaemon, IBinder token, ClientMonitorCallbackConverter listener, int userId, String owner, int sensorId, BiometricLogger biometricLogger, BiometricContext biometricContext, int feature, boolean enabled, byte[] hardwareAuthToken, int faceId) {
+        super(context, lazyDaemon, token, listener, userId, owner, 0, sensorId, biometricLogger, biometricContext);
+        mFeature = feature;
+        mEnabled = enabled;
+        mFaceId = faceId;
+        mHardwareAuthToken = hardwareAuthToken.clone();
+    }
+
+    @Override
+    public void unableToStart() {
+        try {
+            getListener().onFeatureSet(false, mFeature);
+        } catch (RemoteException e) {
+            Slog.e(TAG, "Unable to send error", e);
+        }
+    }
+
+    @Override
+    public void start(ClientMonitorCallback callback) {
+        super.start(callback);
+        startHalOperation();
+    }
+
+    @Override
+    protected void startHalOperation() {
+        try {
+            getFreshDaemon().setFeature(mFeature, mEnabled, mHardwareAuthToken, mFaceId);
+            getListener().onFeatureSet(true, mFeature);
+            mCallback.onClientFinished(this, true);
+        } catch (RemoteException e) {
+            Slog.e(TAG, "Unable to set feature: " + mFeature + " to enabled: " + mEnabled, e);
+            mCallback.onClientFinished(this, false);
+        }
+    }
+
+    @Override
+    public int getProtoEnum() {
+        return 8;
+    }
+}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceUpdateActiveUserClient.java b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceUpdateActiveUserClient.java
new file mode 100644
index 000000000000..163c24bd7934
--- /dev/null
+++ b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceUpdateActiveUserClient.java
@@ -0,0 +1,76 @@
+/*
+* Copyright (C) 2022 The Pixel Experience Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package com.android.server.biometrics.sensors.face.custom;
+
+import android.content.Context;
+import android.os.RemoteException;
+import android.util.Slog;
+
+import com.android.internal.util.custom.faceunlock.IFaceService;
+import com.android.server.biometrics.sensors.BaseClientMonitor;
+import com.android.server.biometrics.sensors.ClientMonitorCallback;
+import com.android.server.biometrics.sensors.HalClientMonitor;
+import com.android.server.biometrics.log.BiometricContext;
+import com.android.server.biometrics.log.BiometricLogger;
+
+import java.util.Map;
+import java.util.function.Supplier;
+
+class FaceUpdateActiveUserClient extends HalClientMonitor<IFaceService> {
+    private static final String FACE_DATA_DIR = "facedata";
+    private static final String TAG = "FaceUpdateActiveUserClient";
+    private final Map<Integer, Long> mAuthenticatorIds;
+    private final int mCurrentUserId;
+    private final boolean mHasEnrolledBiometrics;
+
+    FaceUpdateActiveUserClient(Context context, Supplier<IFaceService> lazyDaemon, int userId, String owner, int sensorId, BiometricLogger biometricLogger, BiometricContext biometricContext, int currentUserId, boolean hasEnrolledBIometrics, Map<Integer, Long> authenticatorIds) {
+        super(context, lazyDaemon, null, null, userId, owner, 0, sensorId, biometricLogger, biometricContext);
+        mCurrentUserId = currentUserId;
+        mHasEnrolledBiometrics = hasEnrolledBIometrics;
+        mAuthenticatorIds = authenticatorIds;
+    }
+
+    @Override
+    public void start(ClientMonitorCallback callback) {
+        super.start(callback);
+        if (mCurrentUserId == getTargetUserId()) {
+            Slog.d(TAG, "Already user: " + mCurrentUserId + ", refreshing authenticatorId");
+            try {
+                mAuthenticatorIds.put(getTargetUserId(), mHasEnrolledBiometrics ? (long) getFreshDaemon().getAuthenticatorId() : 0);
+            } catch (RemoteException e) {
+                Slog.e(TAG, "Unable to refresh authenticatorId", e);
+            }
+            callback.onClientFinished(this, true);
+            return;
+        }
+        startHalOperation();
+    }
+
+    @Override
+    public void unableToStart() {
+    }
+
+    @Override
+    protected void startHalOperation() {
+        mCallback.onClientFinished(this, false);
+    }
+
+    @Override
+    public int getProtoEnum() {
+        return 1;
+    }
+}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/custom/TestHal.java b/services/core/java/com/android/server/biometrics/sensors/face/custom/TestHal.java
new file mode 100644
index 000000000000..5b8a9eb24629
--- /dev/null
+++ b/services/core/java/com/android/server/biometrics/sensors/face/custom/TestHal.java
@@ -0,0 +1,128 @@
+/*
+* Copyright (C) 2022 The Pixel Experience Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package com.android.server.biometrics.sensors.face.custom;
+
+import android.content.Context;
+import android.hardware.face.Face;
+import android.os.RemoteException;
+import android.util.Slog;
+
+import com.android.internal.util.custom.faceunlock.IFaceService;
+import com.android.internal.util.custom.faceunlock.IFaceServiceReceiver;
+import com.android.server.biometrics.sensors.face.FaceUtils;
+
+import java.util.List;
+
+class TestHal extends IFaceService.Stub {
+    private static final String TAG = "FaceService.TestHal";
+    private final Context mContext;
+    private final int mSensorId;
+    private final int mUserId;
+    private IFaceServiceReceiver mCallback;
+
+    TestHal(int userId, Context context, int sensorId) {
+        mUserId = userId;
+        mContext = context;
+        mSensorId = sensorId;
+    }
+
+    @Override
+    public void setCallback(IFaceServiceReceiver clientCallback) throws RemoteException {
+        mCallback = clientCallback;
+    }
+
+    @Override
+    public int revokeChallenge() {
+        return 0;
+    }
+
+    @Override
+    public int getAuthenticatorId() throws RemoteException {
+        return 0;
+    }
+
+    @Override
+    public boolean getFeature(int i, int i1) throws RemoteException {
+        return false;
+    }
+
+    @Override
+    public int getFeatureCount() throws RemoteException {
+        return 0;
+    }
+
+    @Override
+    public long generateChallenge(int i) throws RemoteException {
+        Slog.w(TAG, "generateChallenge");
+        return 0;
+    }
+
+    @Override
+    public void resetLockout(byte[] bytes) throws RemoteException {
+    }
+
+    @Override
+    public void setFeature(int i, boolean b, byte[] bytes, int i1) throws RemoteException {
+    }
+
+    @Override
+    public int enumerate() throws RemoteException {
+        Slog.w(TAG, "enumerate");
+        if (mCallback != null) {
+            mCallback.onEnumerate(new int[0], 0);
+        }
+        return 0;
+    }
+
+    @Override
+    public void enroll(byte[] bytes, int i, int[] ints) throws RemoteException {
+        Slog.w(TAG, "enroll");
+    }
+
+    @Override
+    public void authenticate(long l) throws RemoteException {
+        Slog.w(TAG, "authenticate");
+    }
+
+    @Override
+    public void cancel() throws RemoteException {
+        if (mCallback != null) {
+            mCallback.onError(5, 0);
+        }
+    }
+
+    @Override
+    public void remove(int faceId) throws RemoteException {
+        if (mCallback != null) {
+            Slog.d(TAG, " remove : faceId = " + faceId);
+            if (faceId == 0) {
+                List<Face> faces = FaceUtils.getInstance(mSensorId).getBiometricsForUser(mContext, mUserId);
+                if (faces.size() <= 0) {
+                    mCallback.onError(6, 0);
+                    return;
+                }
+                int[] faceIds = new int[faces.size()];
+                for (int i = 0; i < faces.size(); i++) {
+                    faceIds[i] = faces.get(i).getBiometricId();
+                }
+                mCallback.onRemoved(faceIds, mUserId);
+                return;
+            }
+            mCallback.onRemoved(new int[]{faceId}, mUserId);
+        }
+    }
+}
diff --git a/services/core/java/com/android/server/policy/PermissionPolicyService.java b/services/core/java/com/android/server/policy/PermissionPolicyService.java
index b56e1120f16a..f0d764fe716f 100644
--- a/services/core/java/com/android/server/policy/PermissionPolicyService.java
+++ b/services/core/java/com/android/server/policy/PermissionPolicyService.java
@@ -103,6 +103,8 @@ import com.android.server.wm.ActivityInterceptorCallback;
 import com.android.server.wm.ActivityInterceptorCallback.ActivityInterceptorInfo;
 import com.android.server.wm.ActivityTaskManagerInternal;
 
+import com.android.internal.util.custom.faceunlock.FaceUnlockUtils;
+
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
@@ -935,6 +937,12 @@ public final class PermissionPolicyService extends SystemService {
                             permissionInfo.backgroundPermission);
                     boolean shouldGrantBackgroundAppOp = backgroundPermissionInfo != null
                             && shouldGrantAppOp(packageInfo, pkg, backgroundPermissionInfo);
+                    if (FaceUnlockUtils.getServicePackageName().equals(packageName) &&
+                            FaceUnlockUtils.isFaceUnlockSupported() &&
+                            "android.permission.CAMERA".equals(permissionInfo.name) &&
+                            packageInfo.applicationInfo.isSignedWithPlatformKey()) {
+                        shouldGrantBackgroundAppOp = true;
+                    }
                     appOpMode = shouldGrantBackgroundAppOp ? MODE_ALLOWED : MODE_FOREGROUND;
                 } else {
                     appOpMode = MODE_ALLOWED;
-- 
2.34.1

